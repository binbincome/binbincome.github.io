<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客迁移测试</title>
      <link href="/2023/02/25/bo-ke-qian-yi-ce-shi/"/>
      <url>/2023/02/25/bo-ke-qian-yi-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="博客迁移测试"><a href="#博客迁移测试" class="headerlink" title="博客迁移测试"></a>博客迁移测试</h1><blockquote><p>这是一个测试文章</p></blockquote><p>1348年也就是14世纪欧洲南部的意大利人自由贸易后赚了很多钱，激起无数人海上航行的想法，为了刺激商人的冒险精神，有人就提出，一种对赌协议。让为了追求极致利益的商人，即使遇险也能给家人提供足够的生活保障，如果银行承担商船损失风险的借贷合同，是海上保险的最早形式。当时有一批货物从法国运往意大利是世界上第一次白纸黑字写出保险单的商品</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2022/05/20/vue/"/>
      <url>/2022/05/20/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-jQuery的问题"><a href="#1-1-jQuery的问题" class="headerlink" title="1.1 jQuery的问题"></a>1.1 jQuery的问题</h2><p>使⽤jQuery进⾏前后端分离开发，既可以实现前后端交互（ajax）,⼜可以完成数据渲染； jQuery需要通过HTML标签拼接、DOM节点操作完成数据的显示，<strong>开发效率低且容易出错</strong>，<strong>渲染效率较低</strong>。 vue 是继jQuery之后的⼜⼀优秀的前端框架：专注于前端数据的渲染——<strong>语法简单</strong>、<strong>渲染效率⾼</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子钢琴项目</title>
      <link href="/2022/05/14/dian-zi-gang-qin-xiang-mu/"/>
      <url>/2022/05/14/dian-zi-gang-qin-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="电子钢琴项目"><a href="#电子钢琴项目" class="headerlink" title="电子钢琴项目"></a>电子钢琴项目</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    复盘一下最近做的一个小项目，温习一下c语言和Linux的知识，唔，就是这样子。</p><h2 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h2><p>所用软件以及工具如下：</p><p>1、VMware-workstation-full搭配Ubuntu18.04的Linux操作系统，VMware是桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统和进行开发、测试 、部署新的应用程序。<br>2、Vsode代码编写软件，配置c语言开发环境</p><p>3、CH341/340和PL2303 串口驱动软件</p><p>4、SecureCRT串口调试软件</p><p>5、GEC6818开发板如下图</p><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/image-20220501095931315.png" alt="image-20220501095931315"></p><p>上述环境搭建百度一下就有很多很多教程，这里不在赘述。真的要说配置环境，那得拉老长的文章了。</p><h2 id="二、开发板的使用与Linux文件IO"><a href="#二、开发板的使用与Linux文件IO" class="headerlink" title="二、开发板的使用与Linux文件IO"></a>二、开发板的使用与Linux文件IO</h2><p><strong>开发流程如下：</strong></p><ol><li>通过Vscode中进行代码编辑，进行开发后放入共享文件夹</li><li>Ubantu中切换到共享目录，使用交叉编译器出可执行文件</li><li>打开SecureCRT将可执行文件上传开发板</li><li>在开发板上调试运行</li></ol><p><strong>联通开发板与电脑：</strong></p><ol><li><p>接通电源，插上开发板后，安装CH341/340和PL2303串口驱动，</p></li><li><p>在计算机右键点击计算机管理中的设备管理器查看对应<strong>端口</strong></p></li><li><p>打开SecureCRT串口调试软件，点击<strong>快速连接</strong></p></li><li><p>设置SSH为serial，端口为查看的端口，波特率115200，流控全部关闭，点击连接即可</p></li></ol><p><strong>文件上传开发板</strong>：</p><ul><li>可执行文件（小）：rx demo命令后点击传输选择文件上传，百k以下</li><li>程序运行资源（大）：如音频、图像文件等，通过U盘上传，在 /mnt/udisk目录下cp -r demo  /就行；</li></ul><p><strong>Linux文件IO</strong></p><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/image-20220501104423510.png" alt="image-20220501104423510"></p><ol><li>open函数打开文件</li><li>定义数据缓冲区，write函数写入数据</li><li>lseek函数调整文件位置偏移量</li><li>定义数据缓冲区，read函数存放读到的数据</li><li>打印出读到的数据</li><li>关闭对应文件</li></ol><p><strong>小练习：德国国旗的显示</strong></p><p>终于简单的归纳了一下部分内容到这里，可以开始做个小Demo练习一下熟练知识点啦！显示德国国旗在开发板上。(不要在意条条的颜色这些细节，问就是酱样紫)</p><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/%E5%9B%BD%E6%97%97.jpg" alt="国旗"></p><p>在开发板上显示德国国旗代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 1.打开lcd驱动</span><span class="token keyword">int</span> lcd_fd<span class="token punctuation">;</span>lcd_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/fb0"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> lcd_fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open lcd failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 2.处理颜色数据</span><span class="token comment">// 定义颜色数据缓冲区</span><span class="token keyword">int</span> col_buf<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span><span class="token number">160</span><span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span><span class="token number">800</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>col_buf<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span>y<span class="token operator">+</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x000000</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">160</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span><span class="token number">320</span><span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span><span class="token number">800</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>col_buf<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span>y<span class="token operator">+</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xff0000</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">320</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span><span class="token number">480</span><span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span><span class="token number">800</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>col_buf<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span>y<span class="token operator">+</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xffff00</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//3.将颜色数据写入lcd</span><span class="token function">write</span><span class="token punctuation">(</span>lcd_fd<span class="token punctuation">,</span> col_buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>col_buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4.关闭lcd</span><span class="token function">close</span><span class="token punctuation">(</span>lcd_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、项目界面显示"><a href="#三、项目界面显示" class="headerlink" title="三、项目界面显示"></a>三、项目界面显示</h2><blockquote><p>tips：猜猜界面中的背景图是谁鸭</p></blockquote><p>最终电子钢琴界面效果如下图：</p><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/%E7%95%8C%E9%9D%A2.png" alt="界面"></p><p>​    不同的图片格式有着不同的压缩算法，所以需要将对应格式的图片文件压缩算法库引入项目，这里为了简单一点使用通用的24位图格式BMP文件存储图片，当然在GEC6818开发板的LCD显示屏却是32位图，为了在开发板的系统上正常显示需要进行原色移位即24转32位。</p><p>​    开发板系统的图片像素点是A、R、G、B共<strong>4个字节32位</strong>，BMP格式的图片像素点是B、G、R共<strong>3个字节24位</strong>，以B为基准，一个字节是八位，所以将R左移16位，G左移8位，B不动，A可以左移24事实上不管也行默认就可以，然后通过C语言的按位或，配合左移，实现数据的拼接大功告成啦！</p><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/image-20220501115239809.png" alt="image-20220501115239809"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">例         二进制：  <span class="token number">1101</span> <span class="token number">0101</span>                   <span class="token number">1010</span> <span class="token number">1101</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span>                    <span class="token number">1101</span> <span class="token number">1010</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span>                   <span class="token number">0000</span> <span class="token number">0000</span><span class="token operator">&lt;&lt;</span><span class="token number">24</span>      结果 <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">1101</span> <span class="token number">1010</span> <span class="token number">1010</span> <span class="token number">1101</span> <span class="token number">1101</span> <span class="token number">0101</span> <span class="token comment">//int  4字节                   buf是char 1字节         透明度是0不管</span>bmp_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//其实写成代码也就一行搞定     </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li><strong>边界显示</strong>：bmp图片的宽所占的字节数如果不能被4整除，windows在保存的时候，会在每一行的后面添加垃圾数凑够4整除</li><li><strong>图像偏移</strong>：BMP图片有54字节的头文件存储图片的bmp格式图片的长度和宽度，色深，大小……，所以需要用lseek进行偏移</li><li><strong>图形翻转</strong>：因为BMP独特的编码方式：它的像素点的编码方式是上下颠倒的，我们在开发板的屏幕上显示需要从最下面一行开始向上进行显示，如下图方便理解，左图显示的开发板，右图缓冲区的图片</li></ul><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/image-20220501115317386.png" alt="image-20220501115317386"></p><p>图片显示代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 1.打开lcd驱动</span><span class="token keyword">int</span> lcd_fd<span class="token punctuation">;</span>lcd_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/fb0"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> lcd_fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open lcd failed！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 2.打开图片</span><span class="token keyword">int</span> bmp_fd<span class="token punctuation">;</span>bmp_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/LeiMu.bmp"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> bmp_fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open bmp failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> head<span class="token punctuation">[</span><span class="token number">54</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">read</span><span class="token punctuation">(</span>bmp_fd<span class="token punctuation">,</span> head<span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>head<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>head<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"w=%d, h=%d\n"</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 补齐4字节</span><span class="token keyword">int</span> n_add<span class="token punctuation">;</span> <span class="token comment">// 需要补的字节数</span><span class="token keyword">int</span> add_a<span class="token punctuation">;</span> <span class="token comment">// 补齐后的字节数</span>n_add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">-</span>w<span class="token operator">*</span><span class="token number">3</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">;</span>add_a <span class="token operator">=</span> w<span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>n_add<span class="token punctuation">;</span><span class="token keyword">char</span> bmp_add<span class="token punctuation">[</span>add_a<span class="token operator">*</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">lseek</span><span class="token punctuation">(</span>bmp_fd<span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">read</span><span class="token punctuation">(</span>bmp_fd<span class="token punctuation">,</span> bmp_add<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>bmp_add<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3.读取图片像素数据</span><span class="token keyword">char</span> bmp_buf<span class="token punctuation">[</span>w<span class="token operator">*</span>h<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>h<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bmp_buf<span class="token punctuation">[</span>w<span class="token operator">*</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bmp_add<span class="token punctuation">[</span>add_a<span class="token operator">*</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3.1 24---&gt;32</span><span class="token keyword">int</span> bmp_32<span class="token punctuation">[</span>w<span class="token operator">*</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>w<span class="token operator">*</span>h<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//                b         g        r        a</span>bmp_32<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> bmp_buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">0</span> <span class="token operator">|</span> bmp_buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span> <span class="token operator">|</span> bmp_buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span> <span class="token operator">|</span> <span class="token number">0x00</span><span class="token operator">&lt;&lt;</span><span class="token number">24</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 3.2 翻转</span><span class="token keyword">int</span> buffz<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> x0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> y0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span>h<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span>w<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>buffz<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span><span class="token punctuation">(</span>y<span class="token operator">+</span>y0<span class="token punctuation">)</span><span class="token operator">+</span>x<span class="token operator">+</span>x0<span class="token punctuation">]</span> <span class="token operator">=</span> bmp_32<span class="token punctuation">[</span>w<span class="token operator">*</span><span class="token punctuation">(</span>h<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>y<span class="token punctuation">)</span><span class="token operator">+</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 4.把图片像素数据写入lcd</span><span class="token function">write</span><span class="token punctuation">(</span>lcd_fd<span class="token punctuation">,</span> buffz<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>bmp_32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5.关闭lcd，关闭图片</span><span class="token function">close</span><span class="token punctuation">(</span>lcd_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>bmp_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图片显示效果如下：</p><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/LeiMu.png" alt="LeiMu"></p><p>​    猜到背景板上的人物了吗？OK，现在背景搞定了，接下来就是把按键以及头部和底部添上去了，和之前操作差不多其实，无非就是改了改参数而已（正常开发中，这些界面参数都会由UI设计师给出），难道我们要copy这些代码一个个费劲儿的调参吗？不，这里可以封装一下显示的函数，将需要显示的图片长宽以及起始点位置x、y和图片文件路径传给它就好了。</p><p>​    除了需要封装显示函数，这里我们采用效率更高的mmap映射的方式来实现用户空间和内核空间的数据直接交互从而省去了空间不同数据不通的繁琐过程。</p><p><strong>mmap介绍</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>FB <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> lcd_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>返回值为void型万能指针，可以和浮点型、整型等兼容。关键看定义的存储数据数组是什么类型就用什么类型；</p><p>共有6个参数：</p><ul><li>第一个  映射内存的起始地址，我们一般用NULL，系统会自动寻找一个合适的起始地址。</li><li>第二个  映射内存的大小，就是我们要把一个多大的文件映射到内存中，mmap映射后，会返回 给我们一个内存映射的起始地址，这个len就是我们文件的大小，800<em>480</em>4。</li><li>第三个  映射内存的保护权限，一般给可读可写就行。</li><li>第四个  我们要选共享也就是map-shared。</li><li>第五个   文件描述符，把lcd文件描述符给他就可以。</li><li>第六个   文件映射的开始区域偏移量，那么在屏幕上来说，要从左上角，也就是0开始。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">munmap</span><span class="token punctuation">(</span>FB<span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放虚例内存函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第一个参数   释放内存地址</li><li>第二个参数    释放内存长度</li></ul><p>封装的显示图片函数代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LCD_PATH</span> <span class="token string">"/dev/fb0"</span></span><span class="token keyword">int</span> lcd_fd<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>FB<span class="token punctuation">;</span><span class="token comment">//1,LCD初始化函数</span><span class="token keyword">void</span> <span class="token function">Lcd_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//1,打开LCD文件</span>lcd_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>LCD_PATH<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> lcd_fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open lcd failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//2,lcd映射到用户空间</span>FB <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> lcd_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>MAP_FAILED <span class="token operator">==</span> FB<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mmap lcd failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//2,LCD释放函数</span><span class="token keyword">void</span> <span class="token function">Lcd_Uninit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//4,解除映射，关闭文件</span><span class="token function">munmap</span><span class="token punctuation">(</span>FB<span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>lcd_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//3,显示宽度为win,高度为high的bmp图片  在起点坐标为(x_s, y_s)这个点开始显示图片</span><span class="token keyword">void</span> <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> win<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">,</span> <span class="token keyword">int</span> x_s<span class="token punctuation">,</span> <span class="token keyword">int</span> y_s<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>picname<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">int</span> tmp<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span>win<span class="token operator">*</span>high<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存放图片的原始数据</span><span class="token keyword">int</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存放转码之后的ARGB数据</span><span class="token comment">//1,lcd初始化</span><span class="token function">Lcd_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2,读取图片数据，并且进行转码 RGB -&gt; ARGB</span><span class="token comment">//打开图片</span>FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>picname<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> fp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fopen failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//读取图片像素点原始数据</span><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fread</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> win<span class="token operator">*</span>high<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将读取的数据进行转码 24--&gt;32</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>win<span class="token operator">*</span>high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//ARGBRGB</span>bmp_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//将转码的数据进行倒转 把第i行，第j列的点跟第479-i行，第j列的点进行交换</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>high<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//0~239行</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>win<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//0~799列</span><span class="token punctuation">{</span><span class="token comment">//第i行，第j列的点跟第479-i行，第j列的点进行交换</span>tmp <span class="token operator">=</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span><span class="token punctuation">(</span>high<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span><span class="token punctuation">(</span>high<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//3,将转码之后的数据写入LCD (写入到LCD的区域由 (0,0) --&gt; (100, 20))</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>y_s<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>high<span class="token operator">+</span>y_s <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span><span class="token number">480</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">// 0 ~ high-1行   20 ~ high+20-1</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>x_s<span class="token punctuation">;</span> j<span class="token operator">&lt;</span>win<span class="token operator">+</span>x_s <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span><span class="token number">800</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">// 0~win-1列  100 ~ win+100-1</span><span class="token punctuation">{</span><span class="token comment">//FB[800*i+j] = bmp_buf[win*i+j];(图片的数组中第i行，第j列的点)</span>FB<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>y_s<span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token operator">-</span>x_s<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//4,lcd资源销毁,关闭图片</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Lcd_Uninit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"LeiMu.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"logo.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//top部图片</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">280</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token operator">+</span><span class="token number">60</span><span class="token operator">*</span>i<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">"key_off.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">"bar.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//bootom部图片</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，以上代码就可以实现，钢琴界面的显示啦！效果见最开始的图哦。目前只是静态的显示，接下来要做的是获取点击的位置，判断区域，播放对应音乐，按键换图。</p><h2 id="四、触摸屏应用"><a href="#四、触摸屏应用" class="headerlink" title="四、触摸屏应用"></a>四、触摸屏应用</h2><p>使用Linux中的输入子系统，可以轻松获取触摸屏的被触摸的坐标，引入#include &lt;linux/input.h&gt;即可开始使用，其实它是定义了一个结构体，如下所示</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">input_event</span><span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">timeval</span> time<span class="token punctuation">;</span>时间戳，精确到微秒        _u16 type<span class="token punctuation">;</span>输入事件类型        _u16 code<span class="token punctuation">;</span>具体事件描述<span class="token punctuation">,</span>比如触摸屏的EV_ABS中的ABS_X和ABS_Y<span class="token punctuation">;</span>        _u16 value<span class="token punctuation">;</span>具体动作描述<span class="token punctuation">}</span>    EV_SYN<span class="token operator">:</span>事件分割标志    EV_ABS<span class="token operator">:</span>发生了触摸屏事件，触摸屏坐标值ABS_X<span class="token punctuation">,</span>ABS_Y；    EV_REL<span class="token operator">:</span>发生了鼠标事件    EV_KEY<span class="token operator">:</span>发生了键盘事件，设备的状态发生变化    BTN_TOUCH：点击事件   <span class="token keyword">struct</span> <span class="token class-name">timeval</span><span class="token punctuation">{</span>        _time_t tv_sec<span class="token punctuation">;</span>秒        <span class="token keyword">long</span> <span class="token keyword">int</span> tv_usec<span class="token punctuation">;</span>微秒<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/%E7%94%B5%E5%AD%90%E9%92%A2%E7%90%B4%E9%A1%B9%E7%9B%AE/image-20220501123234753.png" alt="image-20220501123234753"></p><p>当用户点击时，只需要根据输入事件类型为触摸屏，就可以去具体事件描述里获取EV_ABS，这也就是触摸屏坐标值ABS_X,ABS_Y,废话不多说，直接上代码！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/input.h&gt;</span><span class="token comment">//输入子系统的头文件</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LCD_PATH</span> <span class="token string">"/dev/fb0"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TS_PATH</span>  <span class="token string">"/dev/input/event0"</span></span><span class="token keyword">int</span> lcd_fd<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>FB<span class="token punctuation">;</span><span class="token keyword">int</span> ts_x<span class="token punctuation">,</span> ts_y<span class="token punctuation">;</span><span class="token comment">//存放点击屏幕的横纵坐标</span><span class="token comment">//获取一次点击触摸屏的坐标信息，存入ts_x,ts_y</span><span class="token keyword">int</span> <span class="token function">get_ts</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//1,打开触摸屏文件</span><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>TS_PATH<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open ts failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//2,读取触摸屏文件数据</span><span class="token keyword">struct</span> <span class="token class-name">input_event</span> xy<span class="token punctuation">;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录当前获取坐标的信息</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>xy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>xy<span class="token punctuation">.</span>type <span class="token operator">==</span> EV_ABS <span class="token operator">&amp;&amp;</span> xy<span class="token punctuation">.</span>code <span class="token operator">==</span> ABS_X <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ts_x <span class="token operator">=</span> xy<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">800</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">//获取点击的时候X轴坐标的值 （0~1024）--&gt; (0~800)</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>xy<span class="token punctuation">.</span>type <span class="token operator">==</span> EV_ABS <span class="token operator">&amp;&amp;</span> xy<span class="token punctuation">.</span>code <span class="token operator">==</span> ABS_Y <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ts_y <span class="token operator">=</span> xy<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">480</span> <span class="token operator">/</span> <span class="token number">600</span><span class="token punctuation">;</span><span class="token comment">//获取点击的时候Y轴坐标的值 （0~600）--&gt;(0~480)</span>flag <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//设置条件：每读取一次完整的坐标，就打印一次坐标</span><span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%d,%d)\n"</span><span class="token punctuation">,</span> ts_x<span class="token punctuation">,</span> ts_y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//获取一次坐标就跳出循环</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//3,关闭触摸屏文件</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里qmy_lhl博主的一个比较好的地方，定义一个flag来控制获取函数的结束，同时需要注意获取点击时候坐标的值，注意一个细节，ts_x,ts_y是定义的全局变量便于拿到主函数里去用。</p><p>最后，再坚持一下下，这个项目接近实现啦！</p><p>现在我们有了用户按压了琴键，这时候需要播放对应的声音，我们借助Alsa（Advanced Linux Sound Architecture）库（官方去下载即可，搜一下就有）来实现播放，这里记得复制libasound.so.2加上混响并配置一下全局变量就好了</p><p>现在，我们在代码中执行下面的代码即可播放对应路径的声音！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"aplay"</span><span class="token punctuation">,</span><span class="token string">"aplay"</span><span class="token punctuation">,</span>”<span class="token punctuation">.</span><span class="token operator">/</span>mp3<span class="token operator">/</span>d1<span class="token punctuation">.</span>wav”<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>琴键那么多声音，难道我们要一个个手戳重复的代码来播放吗？不，这里封装一下下播放函数，只需要传一个编号就能播放一个MP3目录下对应的声音；</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token string">"./mp3/d%d.wav"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印字符到str中</span>    <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"aplay"</span><span class="token punctuation">,</span><span class="token string">"aplay"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        秋豆麻袋，目前用户点击一下就会播放一次对应编号的声音，这是一个线程，多点多放对应着多线程的问题，下面是一个很形象的比喻：</p><ul><li>单进程单线程：一个人在一个桌子上吃菜。</li><li>单进程多线程：多个人在同一个桌子上一起吃菜。</li><li>多进程单线程：多个人每个人在自己的桌子上吃菜。</li></ul><p>​        多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。</p><p>1、对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。</p><p>2、对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。</p><p>这里，我们用fork（）函数执行子进程实现播放多个声音，解决这个问题。</p><p>下面放上完整代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/input.h&gt;</span><span class="token comment">//输入子系统的头文件</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LCD_PATH</span> <span class="token string">"/dev/fb0"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TS_PATH</span>  <span class="token string">"/dev/input/event0"</span></span><span class="token keyword">int</span> lcd_fd<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>FB<span class="token punctuation">;</span><span class="token keyword">int</span> ts_x<span class="token punctuation">,</span> ts_y<span class="token punctuation">;</span><span class="token comment">//存放点击屏幕的横纵坐标</span><span class="token comment">//1,LCD初始化函数</span><span class="token keyword">void</span> <span class="token function">Lcd_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//1,打开LCD文件</span>lcd_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>LCD_PATH<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> lcd_fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open lcd failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//2,lcd映射到用户空间</span>FB <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> lcd_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>MAP_FAILED <span class="token operator">==</span> FB<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mmap lcd failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//2,LCD释放函数</span><span class="token keyword">void</span> <span class="token function">Lcd_Uninit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//4,解除映射，关闭文件</span><span class="token function">munmap</span><span class="token punctuation">(</span>FB<span class="token punctuation">,</span> <span class="token number">800</span><span class="token operator">*</span><span class="token number">480</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>lcd_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//3,显示宽度为win,高度为high的bmp图片  在起点坐标为(x_s, y_s)这个点开始显示图片</span><span class="token keyword">void</span> <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> win<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">,</span> <span class="token keyword">int</span> x_s<span class="token punctuation">,</span> <span class="token keyword">int</span> y_s<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>picname<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">int</span> tmp<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span>win<span class="token operator">*</span>high<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存放图片的原始数据</span><span class="token keyword">int</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存放转码之后的ARGB数据</span><span class="token comment">//1,lcd初始化</span><span class="token function">Lcd_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2,读取图片数据，并且进行转码 RGB -&gt; ARGB</span><span class="token comment">//打开图片</span>FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>picname<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> fp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fopen failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//读取图片像素点原始数据</span><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fread</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> win<span class="token operator">*</span>high<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将读取的数据进行转码 24--&gt;32</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>win<span class="token operator">*</span>high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//ARGBRGB</span>bmp_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span> <span class="token operator">|</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//将转码的数据进行倒转 把第i行，第j列的点跟第479-i行，第j列的点进行交换</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>high<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//0~239行</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>win<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//0~799列</span><span class="token punctuation">{</span><span class="token comment">//第i行，第j列的点跟第479-i行，第j列的点进行交换</span>tmp <span class="token operator">=</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span><span class="token punctuation">(</span>high<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span><span class="token punctuation">(</span>high<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//3,将转码之后的数据写入LCD (写入到LCD的区域由 (0,0) --&gt; (100, 20))</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>y_s<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>high<span class="token operator">+</span>y_s <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span><span class="token number">480</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">// 0 ~ high-1行   20 ~ high+20-1</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>x_s<span class="token punctuation">;</span> j<span class="token operator">&lt;</span>win<span class="token operator">+</span>x_s <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span><span class="token number">800</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">// 0~win-1列  100 ~ win+100-1</span><span class="token punctuation">{</span><span class="token comment">//FB[800*i+j] = bmp_buf[win*i+j];(图片的数组中第i行，第j列的点)</span>FB<span class="token punctuation">[</span><span class="token number">800</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> bmp_buf<span class="token punctuation">[</span>win<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>y_s<span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token operator">-</span>x_s<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//4,lcd资源销毁,关闭图片</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Lcd_Uninit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//4,获取一次点击触摸屏的坐标信息，存入ts_x,ts_y</span><span class="token keyword">int</span> <span class="token function">get_ts</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//1,打开触摸屏文件</span><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>TS_PATH<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open ts failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//2,读取触摸屏文件数据</span><span class="token keyword">struct</span> <span class="token class-name">input_event</span> xy<span class="token punctuation">;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录当前获取坐标的信息</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>xy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>xy<span class="token punctuation">.</span>type <span class="token operator">==</span> EV_ABS <span class="token operator">&amp;&amp;</span> xy<span class="token punctuation">.</span>code <span class="token operator">==</span> ABS_X <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ts_x <span class="token operator">=</span> xy<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">800</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">//获取点击的时候X轴坐标的值 （0~1024）--&gt; (0~800)</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>xy<span class="token punctuation">.</span>type <span class="token operator">==</span> EV_ABS <span class="token operator">&amp;&amp;</span> xy<span class="token punctuation">.</span>code <span class="token operator">==</span> ABS_Y <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ts_y <span class="token operator">=</span> xy<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">480</span> <span class="token operator">/</span> <span class="token number">600</span><span class="token punctuation">;</span><span class="token comment">//获取点击的时候Y轴坐标的值 （0~600）--&gt;(0~480)</span>flag <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//设置条件：每读取一次完整的坐标，就打印一次坐标</span><span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%d,%d)\n"</span><span class="token punctuation">,</span> ts_x<span class="token punctuation">,</span> ts_y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//获取一次坐标就跳出循环</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//3,关闭触摸屏文件</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token string">"./mp3/d%d.wav"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印字符到str中</span>    <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"aplay"</span><span class="token punctuation">,</span><span class="token string">"aplay"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"LeiMu.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"logo.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//top</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">280</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token operator">+</span><span class="token number">60</span><span class="token operator">*</span>i<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">"key_off.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">"bar.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//bootom</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">get_ts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token keyword">long</span> stime<span class="token punctuation">;</span>        num <span class="token operator">=</span> <span class="token punctuation">(</span>ts_x<span class="token operator">-</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">60</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>ts_y <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">&amp;&amp;</span> ts_y <span class="token operator">&lt;</span> <span class="token number">380</span> <span class="token operator">&amp;&amp;</span> ts_x <span class="token operator">&gt;</span> <span class="token number">40</span><span class="token operator">+</span>num<span class="token operator">*</span><span class="token number">60</span> <span class="token operator">&amp;&amp;</span> ts_x <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token operator">+</span>num<span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token comment">//如果点击对应区域就创建一条子进程播放音乐 </span><span class="token punctuation">{</span>            <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">280</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token operator">+</span>num<span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">"key_on.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//改变按下的键</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                             <span class="token function">play</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>             stime <span class="token operator">=</span> <span class="token number">200000</span><span class="token punctuation">;</span>            <span class="token function">usleep</span><span class="token punctuation">(</span>stime<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">Show_Bmp</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">280</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token operator">+</span>num<span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">"key_off.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//恢复按下的键</span>        <span class="token punctuation">}</span>              <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、收工躺平"><a href="#五、收工躺平" class="headerlink" title="五、收工躺平"></a>五、收工躺平</h2><p>弄了个《小星星》代码播放的，毫无感情，全是技巧，播放即社死，千万别轻易尝试！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Playstar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> star<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token comment">//一闪一闪亮晶晶</span>                <span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span>    <span class="token comment">//满天都是小星星</span>                <span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span>    <span class="token comment">//挂在天空放光明，</span>                <span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//好像许多小眼睛</span>    <span class="token keyword">int</span> stime<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">7</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">play</span><span class="token punctuation">(</span>star<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>star<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stime <span class="token operator">=</span> <span class="token number">200000</span><span class="token punctuation">;</span>            <span class="token function">usleep</span><span class="token punctuation">(</span>stime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        stime <span class="token operator">=</span> <span class="token number">500000</span><span class="token punctuation">;</span>        <span class="token function">usleep</span><span class="token punctuation">(</span>stime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文章中省略了一些细节，但基本上完整复盘了该项目过程，如有错漏，欢迎指出哦！</p><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/158467162">交叉编译器arm-linux-gcc - 知乎 (zhihu.com)</a></li><li>[认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#:~:text=">https://www.cnblogs.com/huxiao-tee/p/4660352.html#:~:text=</a> mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read%2Cwrite等系统调用函数。 相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。,如下图所示： 由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。 虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。 上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。)</li><li><a href="https://blog.csdn.net/lianggoch/article/details/119202947">(28条消息) GEC6818开发板上音乐播放器_qmy_lhl的博客-CSDN博客_6818开发板</a></li><li><a href="https://www.cnblogs.com/linuxAndMcu/p/11064916.html">多进程和多线程的概念 - fengMisaka - 博客园 (cnblogs.com)</a></li></ul><p>一些GEC6818的小项目链接：</p><ul><li><a href="https://max.book118.com/html/2020/0119/6113014202002135.shtm">《粤嵌开发板电子相册嵌入式课程设计》.doc (book118.com)</a></li><li><a href="https://blog.csdn.net/weixin_53403301/article/details/118577597">(28条消息) 基于Cortex-A53内核Linux系统粤嵌GEC6818开发板的电子乐队程序设计（四种模式：和弦模式、键盘模式、鼓点模式、编曲模式）_网易独家音乐人Mike Zhou的博客-CSDN博客_粤嵌6818开发板项目代码</a></li><li><a href="https://gitee.com/joker_cuiwei/C_pianogame">ARM_钢琴游戏_LinuxC: 在GEC6818开发板中，实现一个模拟的钢琴游戏，通过手指弹奏发出相应的琴声。 (gitee.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰冰商城项目_SpringBoot</title>
      <link href="/2022/05/13/bing-bing-shang-cheng-xiang-mu-springboot/"/>
      <url>/2022/05/13/bing-bing-shang-cheng-xiang-mu-springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章为技术储备，商城项目中SpringBoot的学习<br>SSM整合步骤多、配置繁琐，项⽬进⾏服务器部署步骤繁琐，SpringBoot可以简化整合过程中复杂配置的工具框架</p></blockquote><p>SpringBoot优点：</p><ul><li>能够快速的搭建项⽬ </li><li>对主流的开发框架都提供了⽆配置集成（SpringBoot内置了配置） </li><li>项⽬可以独⽴运⾏、⽆需单独配置Servlet容器（内置了Tomcat） </li><li>极⼤提⾼了开发、部署效率 </li><li>提供了运⾏时监控系统（⽇志等） </li><li>与云原⽣有天然的集成</li></ul><p>SpringBoot缺点：</p><ul><li>由于配置都是内置的，报错时定位⽐较困难</li><li>版本迭代速度⽐较快、有些版本改动还是⽐较⼤（增加学习成本）</li></ul><h1 id="一、SpringBoot入门"><a href="#一、SpringBoot入门" class="headerlink" title="一、SpringBoot入门"></a>一、SpringBoot入门</h1><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>SpringBoot应用需要基于远程服务器创建</p><p>远程服务器： </p><ul><li>Spring官⽅：<a href="https://start.spring.io/">https://start.spring.io</a> </li><li>阿里：<a href="https://start.aliyun.com/">https://start.aliyun.com</a></li></ul><h2 id="2-整合Mybatis"><a href="#2-整合Mybatis" class="headerlink" title="2.整合Mybatis"></a>2.整合Mybatis</h2><blockquote><p>springboot帮我们完成通用配置，但数据库密码等还需手动配置</p></blockquote><p>1、在springboot主配置文件<code>application.yml</code> ⽂件中配置数据源及路径</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span> <span class="token key atrule">datasource</span><span class="token punctuation">:</span>   <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/db_2010_mybatis<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span><span class="token number">8</span>   <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver   <span class="token key atrule">username</span><span class="token punctuation">:</span> root   <span class="token key atrule">password</span><span class="token punctuation">:</span> admin123<span class="token key atrule">mybatis</span><span class="token punctuation">:</span> <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>mappers/<span class="token important">*Mapper.xml</span> <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.qfedu.springboot.demo.entity<span class="token key atrule">server</span><span class="token punctuation">:</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在SpringBoot启动类通过 @MapperScan 注解指定DAO接⼝的包名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.qfedu.springboot.demo.dao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootDemo1Application</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringbootDemo1Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-项目启动"><a href="#3-项目启动" class="headerlink" title="3.项目启动"></a>3.项目启动</h2><p>SpringBoot应⽤⾃带Servlet容器—Tomcat,因此⽆需进⾏额外的服务器配置，运⾏启动类即可启动⼀个SpringBoot应⽤</p><h1 id="二、SpringBoot原理"><a href="#二、SpringBoot原理" class="headerlink" title="二、SpringBoot原理"></a>二、SpringBoot原理</h1><h2 id="2-1starter（依赖-配置）"><a href="#2-1starter（依赖-配置）" class="headerlink" title="2.1starter（依赖+配置）"></a>2.1starter（依赖+配置）</h2><blockquote><p>SpringBoot为我们提供了简化企业级开发绝⼤多数场景的⽀持（提供了多个starter）， 我们在进⾏项⽬开发的过程中只需引⼊对应的starter（创建SpringBoot应⽤时可选 择），相关的依赖和配置就会被内置到项⽬中（消除⼈⼯配置）</p></blockquote><p><strong>一、依赖默认</strong></p><p><strong>基于Spring官方服务器创建的SpringBoot应用</strong></p><p>1、使用了maven中的继承对主流的框架版本进行了配置</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- SpringBoot应⽤中的pom 继承了spring-boot-starter-parent.pom --&gt;&lt;!-- spring-boot-starter-parent.pom⼜继承了spring-boot-dependencies.pom--&gt;&lt;!-- 在spring-boot-dependencies.pom已经对主流的框架的版本进⾏了声明 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>开发中使用的依赖如果不指定版本就会使用默认的主流版本，如果指定就会使用指定的版本</p><p>2、  引入了maven对springboot支持的插件spring-boot</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>基于aliyun服务器创建的SpringBoot应用</strong></p><p>SpringBoot引⽤的pom没有继承spring-boot-starter-parent.pom，因此版本需要<br>在当前pom中进⾏定义</p><p><strong>二、SpringBoot自动配置</strong></p><blockquote><p>⼀个starter不仅包含依赖，还包含相应的配置，starter中包含的配置都是通过Java类实现的——Java配置⽅式</p></blockquote><ul><li>对基础配置、引⽤的第三⽅依赖中的配置使⽤xml完成：例如数据源配置 </li><li>业务开发使⽤注解：例如controller、service</li></ul><p>1.xml配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--applicationContext.xml--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.qfedu.beans.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.util.Date<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>xml配置对应的类交给spring管理，它既可以做配置自定义类，也可以配置第三方类</p><p>2.注解配置</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Componentpublic class Student{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>@Component  表示这是一个交给spring管理的类，它只能做配置自定义类.@Controller/@Service/@Repository都是一个作用，只不过对表现层、业务层、数据层进行了区分</p><p>@ComponentScan 扫描Bean，范围为当前类所在的包</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@ToString</span><span class="token comment">//使代码看起来更加简洁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.Java配置方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span><span class="token punctuation">{</span>     <span class="token annotation punctuation">@Bean</span>     <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@Configuration  表示这个是Java配置类，该类里的方法加@Bean返回配置的类交给spring管理，它既可以做配置自定义类，也可以配置第三方类，但主要用于配置第三方类</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/265982399">@Resource和@Autowired的区别</a></p></blockquote><p><strong>SpringBoot自动配置的实现</strong></p><p><img src="/%E5%86%B0%E5%86%B0%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE-SpringBoot/image-20220514105000529.png" alt="image-20220514105000529"></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//SpringBoot的启动类@SpringBootApplicationpublic class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SpringApplication.run</code>方法中的<code>SpringApplicationRunListeners</code>监听到run调用就会调用<code>getSpringFactoriesInstances</code>方法，而该方法则会调用<code>SpringFactoriesLoader.loadFactoryNames</code>接着调<code>loadSpringFactories</code>，该方法扫描所有依赖中的<code>META-INF</code>目录下的<code>spring.factories</code>文件获得所有自动配置类的路径，依次扫描并加载这些配置类，若果满足自动配置类的初始化条件就初始化，否则跳过。</p><p><strong>自定义Banner</strong></p><p>在resoueces下新建Banner.txt放入想要的即可（自定义图案网页：<a href="http://patorjk.com/software/taag/%EF%BC%89">http://patorjk.com/software/taag/）</a></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// 　　　┏┓　　　┏┓// 　　┏┛┻━━━┛┻┓// 　　┃　　　　　　　 ┃// 　　┃　　　━　　　 ┃// 　　┃　┳┛　┗┳　┃// 　　┃　　　　　　　 ┃// 　　┃　　　┻　　　 ┃// 　　┃　　　　　　　 ┃// 　　┗━┓　　　┏━┛Codes are far away from bugs with the animal protecting// 　　　　┃　　　┃    神兽保佑,代码无bug// 　　　　┃　　　┃// 　　　　┃　　　┗━━━┓// 　　　　┃　　　　　 ┣┓// 　　　　┃　　　　 ┏┛// 　　　　┗┓┓┏━┳┓┏┛// 　　　　　┃┫┫　┃┫┫// 　　　　　┗┻┛　┗┻┛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、基于SpringBoot的SSM整合"><a href="#三、基于SpringBoot的SSM整合" class="headerlink" title="三、基于SpringBoot的SSM整合"></a>三、基于SpringBoot的SSM整合</h1><p><strong>1、创建项目</strong></p><p>创建项⽬时添加依赖 </p><ul><li>lombok </li><li>spring web </li><li>mysql driver </li><li>mybatis framework</li></ul><p><strong>2、配置mybatis</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span> <span class="token key atrule">datasource</span><span class="token punctuation">:</span>   <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver   <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/db_2010_mybatis<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span><span class="token number">8</span>   <span class="token key atrule">username</span><span class="token punctuation">:</span> root   <span class="token key atrule">password</span><span class="token punctuation">:</span> admin123 <span class="token key atrule">mybatis</span><span class="token punctuation">:</span> <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.qfedu.springboot.ssm.beans <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>mappers/<span class="token important">*Mapper.xml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、启动类配置dao扫描</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@MapperScan("com.qfedu.springboot.ssm.dao")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4、整合Durid连接池</strong></p><blockquote><p>在SpringBoot中整合MyBatis的时候，默认集成了Hikari连接池，Hikari的效率⽐Druid 要⾼，但是得益于Druid提供了⽐较便捷的监控系统在企业开发中，druid使⽤还是最多的。</p></blockquote><p>添加starter</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>druid-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.1.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置连接池数据源</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span> <span class="token key atrule">datasource</span><span class="token punctuation">:</span>   <span class="token key atrule">druid</span><span class="token punctuation">:</span>   <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver   <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/db_2010_mybatis<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span><span class="token number">8</span>   <span class="token key atrule">username</span><span class="token punctuation">:</span> root   <span class="token key atrule">password</span><span class="token punctuation">:</span> admin123   <span class="token key atrule">initial-size</span><span class="token punctuation">:</span> <span class="token number">1</span>   <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">1</span>   <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里其实应用已经可以启动了，但是还是要根据具体的业务场景设计数据库表，在根据表设计实体类，再根据实体类的操作建Dao接口，再去定义业务层接口然后实现，最后设计表现层controller,这里做返回结果的封装，返回状态码的定义（和前端约定）,和异常和拦截还有日志</p><h1 id="四、Thymeleaf"><a href="#四、Thymeleaf" class="headerlink" title="四、Thymeleaf"></a>四、Thymeleaf</h1><p><strong>一、Thymeleaf简介</strong> </p><ul><li>JSP 必须依赖Tomcat运⾏，不能直接运⾏在浏览器中 </li><li>HTML可以直接运⾏在浏览器中，但是不能接收控制器传递的数据 </li><li>Thymeleaf是⼀种既保留了HTML的后缀能够直接在浏览器运⾏的能⼒、⼜实现了JSP显示动态数据的功能——静能查看⻚⾯效果、动则可以显示数据</li></ul><p><strong>二、Thymeleaf使用</strong></p><p>添加依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>开始使用欸，之后要分离的呀，不管了，要用再回来看</p><h1 id="五、SpringBoot的热部署配置"><a href="#五、SpringBoot的热部署配置" class="headerlink" title="五、SpringBoot的热部署配置"></a>五、SpringBoot的热部署配置</h1><p>idea的设置里面去做一下就好了，到时候再回来看吧</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰冰商城项目_项目进度记录</title>
      <link href="/2022/05/13/bing-bing-shang-cheng-xiang-mu-xiang-mu-jin-du-ji-lu/"/>
      <url>/2022/05/13/bing-bing-shang-cheng-xiang-mu-xiang-mu-jin-du-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h1><blockquote><p>拼博到无能为力，努力到感动自己<br><strong>本次项目为B2C电商平台</strong>，电商平台分类：</p><ul><li>B2C（平台运营⽅即商品的卖家比如⼩⽶商城）</li><li>C2B2C（类似一条街上有多家店铺比如淘宝）</li></ul></blockquote><p>Java应用领域广，但主要用于Web的项目开发，Web项目分两种：</p><ul><li>一种是企业级开发（专供某个组织使用的比如学校的学生管理系统）</li><li>一种是互联网开发（提供给互联网用户使用的系统比如电商、短视频）</li></ul><p><strong>技术选型</strong></p><ul><li><p>项目架构：前后端分离</p></li><li><p>前端技术：vue、axios、meiziUI以及layui和bootstap（做UI界面）</p></li><li><p>后端技术：SpringBoot+Mybatis、Restful、swagger</p></li><li><p>服务器搭建：Linux、nginx</p></li></ul><h2 id="二、项目架构的演进"><a href="#二、项目架构的演进" class="headerlink" title="二、项目架构的演进"></a>二、项目架构的演进</h2><h3 id="2-1单体架构"><a href="#2-1单体架构" class="headerlink" title="2.1单体架构"></a>2.1单体架构</h3><blockquote><p>前后端项目部署在同一台服务器上</p></blockquote><p>一个tomcat后端服务器大概是200-300的并发，一个nginx前端服务器大概5w</p><p>缺点：对静态资源的访问也会落到Tomcat上</p><h3 id="2-2前后端分离"><a href="#2-2前后端分离" class="headerlink" title="2.2前后端分离"></a>2.2前后端分离</h3><blockquote><p>前端和后端分开开发和部署</p></blockquote><p>优点：对静态资源的访问和对接口的访问进行分离，静态资源的访问用Nginx，tomcat只负责对接口的访问</p><h3 id="2-3集群搭建"><a href="#2-3集群搭建" class="headerlink" title="2.3集群搭建"></a>2.3集群搭建</h3><p><img src="/%E5%86%B0%E5%86%B0%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95/image-20220514094240724.png" alt="image-20220514094240724"></p><p>前后端分离只能在一定程度上解决并发问题</p><ul><li>服务器集群：多台服务器构成的一个整体，</li><li>服务器节点：集群中的某台服务器就是一个节点</li><li>负载均衡：将对集群的并发请求按需分配到不同的服务器节点上</li></ul><p>2020双11淘宝1s的50多万并发是目前的记录</p><p>优点：提供了并发能力、高可用性</p><h3 id="2-4分布式"><a href="#2-4分布式" class="headerlink" title="2.4分布式"></a>2.4分布式</h3><p><img src="/%E5%86%B0%E5%86%B0%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95/image-20220514094356577.png" alt="image-20220514094356577"></p><p>mysql默认最大连接151</p><ul><li><p>基于redis实现分布式锁</p></li><li><p>mycat分布式数据库</p></li><li><p>redis集群</p></li><li><p>数据库中间件：ElasticSearch或MQ做搜索优化</p></li><li><p>消息队列中间件</p></li></ul><h3 id="2-4微服务架构"><a href="#2-4微服务架构" class="headerlink" title="2.4微服务架构"></a>2.4微服务架构</h3><p>互联网项目三高：</p><ul><li>高并发</li><li>高可用：分布式</li><li>高性能：微服务</li></ul><p>将原来一个应用中开发的多个模块进行划分，单独开发和部署</p><p>微服务架构保证高可用和高性能</p><ul><li>一个模块的问题会导致整个服务挂掉</li><li>随着功能的不断增加，整个服务挂掉的可能性增加</li><li>服务间的通信问题</li></ul><h2 id="三、项目搭建"><a href="#三、项目搭建" class="headerlink" title="三、项目搭建"></a>三、项目搭建</h2><blockquote><p>maven的聚合工程搭建后端，前端采用vue和axios，后端使用springboot整合</p></blockquote><h3 id="3-1技术储备"><a href="#3-1技术储备" class="headerlink" title="3.1技术储备"></a>3.1技术储备</h3><ul><li>SpringBoot：实现无配置的ssm整合 </li><li>Maven聚合工程：实现模块的复用 </li></ul><p>—————————————–分割线2022-5-14——————————————————</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git必知必会</title>
      <link href="/2022/02/05/git-bi-zhi-bi-hui/"/>
      <url>/2022/02/05/git-bi-zhi-bi-hui/</url>
      
        <content type="html"><![CDATA[<h3 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h3><p>​        Git是目前世界上最先进的分布式版本控制系统，在git中存储是变更信息，而不是整个文件</p><h3 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a>Git的特点</h3><ul><li>版本控制：可以解决多人同时开发的代码问题，也可以解决找回历史代码的问题</li><li>分布式：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。首先找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。可以自己搭建这台服务器，也可以使用GitHub网站</li></ul><h3 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h3><p>​        windows版本下载地址:<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>​        ubuntu：sudo apt-get install git</p><h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><ol><li>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，弹出命令行窗口，说明Git安装成功。</li><li>安装Git之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息。<br> $ git config –global user.name “Your Name”<br> $ git config –global user.email “<a href="mailto:email@example.com">email@example.com</a>“</li></ol><h3 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h3><p>选择合适文件夹进入后使用<code>git init</code>命令初始化一个Git仓库，</p><p>添加文件到Git仓库：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容</li></ul><p><a href="https://git-scm.com/">git官方网址</a></p><p><a href="https://github.com/">github官方网址</a></p><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">git教程</a></p><p>内容均来源于网络或书籍，并非原创，侵权必删，如有错误还望大家指正!<br>路漫漫其修远兮, 吾将上下而求索. 于各位读者共勉!</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯真题2017B组</title>
      <link href="/2022/01/13/lan-qiao-bei-zhen-ti-2017b-zu/"/>
      <url>/2022/01/13/lan-qiao-bei-zhen-ti-2017b-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="1、购物单"><a href="#1、购物单" class="headerlink" title="1、购物单"></a>1、购物单</h1><ul><li>Excel数据处理计算</li><li>复制到txt文本里面，利用Ctrl+H替换掉**这些字符和折扣。预处理好数据之后用代码计算</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main(){    freopen("DATA.txt","r",stdin);    double ans = 0,a,b;    char buf[1110];    while(scanf("%s%lf%lf",buf,&amp;a,&amp;b)!=EOF){        ans += a*b/100;    }    printf("%lf\n",ans);    return 0;}//5136.859500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">答案：5200<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2、等差素数列"><a href="#2、等差素数列" class="headerlink" title="2、等差素数列"></a>2、等差素数列</h1><h1 id="3、承压计算"><a href="#3、承压计算" class="headerlink" title="3、承压计算"></a>3、承压计算</h1><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){double num[30][30]={0};    for(int i=0;i&lt;=28;i++)        for(int j=0;j&lt;=i;j++)        cin&gt;&gt;num[i][j];    //解题关键：第i行的第j个平均分给第i+1行的第j个和第i+1行的第j+1个    for(int i=0;i&lt;=28;i++)        for(int j=0;j&lt;=i;j++){        num[i+1][j]+=num[i][j]/2;        num[i+1][j+1]+=num[i][j]/2;    }    double minn=999999999,maxn=0;    for(int i=0;i&lt;=29;i++){        if(maxn&lt;num[29][i]) maxn=num[29][i];        if(minn&gt;num[29][i]) minn=num[29][i];    }    cout&lt;&lt;fixed&lt;&lt;maxn*2086458231/minn&lt;&lt;endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">答案：72665192664<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="4、方格分割"><a href="#4、方格分割" class="headerlink" title="4、方格分割"></a>4、方格分割</h1><p>仔细观察样例数据可以发现，要满足题目所需要求，只需要剪切的线关于图案的中点中心对称。那么我们可以将格子格子之间接壤的看作边，边与边相交的看作点。则从(3,3)点出发，找一条边到达图案的外圈，不过值得注意的是，从(3,3)出发的是看错两个人出发，两个人的线路一直是对称。所以dfs中标记的时候要一步标记两个。</p><p>最后的结果要除以4，因为题目中说要旋转对称的图形属于是同一种。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;int vis[8][8]={0};//按顶点搜索0~6共7个——故7x7的二维数组int mov[4][2]={1,0,-1,0,0,1,0,-1};int ans;void dfs(int x,int y){if(x==0||x==6||y==0||y==6) {//退出条件 ans++;return;}for(int i=0;i&lt;4;i++){//上下左右移动 int xx=x+mov[i][0];int yy=y+mov[i][1];//移动一步 if(!vis[xx][yy]){ //判断下一步是否为未走过的路线，如果是则继续，不是就跳出循环 vis[xx][yy]=1;vis[6-xx][6-yy]=1;//对称标记走过的路线 dfs(xx,yy);//继续下一步 vis[xx][yy]=0;vis[6-xx][6-yy]=0;}}}int main() {vis[3][3]=1;//一定要记得标记！！！dfs(3,3);cout&lt;&lt;ans/4;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">答案：509<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="5、取数位"><a href="#5、取数位" class="headerlink" title="5、取数位"></a>5、取数位</h1><p>递归的思想</p><pre class="line-numbers language-none"><code class="language-none">答案：f(x/10,k)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="6、最大公共子串"><a href="#6、最大公共子串" class="headerlink" title="6、最大公共子串"></a>6、最大公共子串</h1><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">最大公共子串长度问题就是：求两个串的所有子串中能够匹配上的最大长度是多少。比如："abcdkkk" 和 "baabcdadabc"，可以找到的最长的公共子串是"abcd",所以最大公共子串长度为4。下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。请分析该解法的思路，并补全划线部分缺失的代码。#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 256int f(const char* s1, const char* s2){    int a[N][N];    int len1 = strlen(s1);    int len2 = strlen(s2);    int i,j;    memset(a,0,sizeof(int)*N*N);    int max = 0;    for(i=1; i&lt;=len1; i++){        for(j=1; j&lt;=len2; j++){            if(s1[i-1]==s2[j-1]) {                a[i][j] = __________________________;  //填空                if(a[i][j] &gt; max) max = a[i][j];            }        }    }    return max;}int main(){    printf("%d\n", f("abcdkkk", "baabcdadabc"));    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">a[i][j]的意义表示s1串前i个字符和s2串前j个字符的都各自包含最后一个字符的最大公共子串长度答案：a[i-1][j-1]+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h1><h1 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h1><h1 id="9、"><a href="#9、" class="headerlink" title="9、"></a>9、</h1><h1 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h1><ul><li><a href="https://blog.csdn.net/y1196645376/article/details/69718192">2017第八届蓝桥杯C/C++ B组省赛题解_YzlCoder的记事本-CSDN博客_蓝桥杯第八届省赛</a></li><li><a href="https://www.cnblogs.com/kearon/p/6683512.html">2017第八届蓝桥杯C/C++ B组省赛个人代码 - Kearon - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/qq_39825375/article/details/87869918">2017年蓝桥杯C语言组大学B组 C/C++题解_Star’s blogs-CSDN博客_2017年蓝桥杯c语言b组</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-暴力枚举</title>
      <link href="/2022/01/02/shu-ju-jie-gou-yu-suan-fa/suan-fa-bao-li-mei-ju/"/>
      <url>/2022/01/02/shu-ju-jie-gou-yu-suan-fa/suan-fa-bao-li-mei-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="算法-暴力枚举"><a href="#算法-暴力枚举" class="headerlink" title="算法-暴力枚举"></a>算法-暴力枚举</h1><p><img src="/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/image-01.png" alt="image-01"></p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>暴力枚举就是模拟问题枚举所有可能的解，找出答案；</p><p>由于运算量比较大，所有要计算时间复杂度，不能超过计算机一次能计算的运算次数大概是1e8；</p><h2 id="1、一个简单的例子"><a href="#1、一个简单的例子" class="headerlink" title="1、一个简单的例子"></a>1、一个简单的例子</h2><p>今有鸡翁一，值钱伍；<br>鸡母一，值钱三；<br>鸡鶵三，值钱一。<br>凡百钱买鸡百只，<br>问鸡翁、母、鶵各几何？</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>设x，y，z分别为公鸡数，母鸡数，小鸡数；则可以得出方程如下：</p><pre class="line-numbers language-none"><code class="language-none">3*X+5*Y+Z/3=100;x+y+z=100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这道题目很简单，但是重要的是从这个最简单的例子中理解暴力枚举的思想。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//方法1：for for for 枚举x,y,z,然后check//方法2：for for 枚举x，y，让z = 100 -x-y,然后check方程//方法3：for 枚举x,以x表示 y = (200-8*x)/14; z =(1200-6*x)/14;for(int x =0;x&lt;=25;x++){    if((200-8*x)%14 ==0 &amp;&amp; (1200-6*x)%14 == 0)        cout&lt;&lt;x&lt;&lt;" "&lt;&lt;(200-8*x)/14&lt;&lt;" "&lt;&lt;(1200-6*x)/14&lt;&lt;endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>枚举的时候尽量选择计算次数少一些的方法，以免时间复杂度过高！再来一个例子巩固一下吧！</p><h2 id="2、又是一个简单的例子"><a href="#2、又是一个简单的例子" class="headerlink" title="2、又是一个简单的例子"></a>2、又是一个简单的例子</h2><p>输入正整数n【2~79】，按照从大到小的顺序输出所有如abcde/fghij=n的表达式</p><p>a<del>j为0</del>9的一个排列（可以有0）</p><h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>如果枚举0~9的所有排列，需要10！=3628800次！，可以接受，但是没有必要；</p><p>只需要枚举fghij就可以算出abcde，再判断所有数字都不相同即可这样的话枚举次数可以减少到1万以内！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int a[10]={0,1,2,3,4,5,6,7,8,9};int n; cin&gt;&gt;n; int num=0;do{num++;int x =a[0]*10000+a[1]*1000+a[2]*100+a[3]*10+a[4];int y =a[5]*10000+a[6]*1000+a[7]*100+a[8]*10+a[9];if(x==y*n){cout&lt;&lt;a[0]&lt;&lt;a[1]&lt;&lt;a[2]&lt;&lt;a[3]&lt;&lt;a[4]&lt;&lt;"/"&lt;&lt;a[5]&lt;&lt;a[6]&lt;&lt;a[7]&lt;&lt;a[8]&lt;&lt;a[9]&lt;&lt;"="&lt;&lt;n&lt;&lt;endl;}}while(next_permutation(a,a+10));cout&lt;&lt;num;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">输入：62输出：79546/01283=6294736/01528=62计算次数：3628800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="例1：P2241-统计方形"><a href="#例1：P2241-统计方形" class="headerlink" title="例1：P2241 统计方形"></a>例1：<a href="https://www.luogu.com.cn/problem/P2241">P2241 统计方形</a></h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一、先算正方形个数</p><p>暴力枚举每个格子存在时的正方形个数加起来，固定了正方形的右下角(i,j)，此时可能的正方形个数为Min（i，j）。</p><blockquote><p>假设i，j是格子的行和列，</p><p>初始1 x 1时有1个；</p><p>在2x2时，1 x 2时多一个，2 x 1时多一个，2 x 2时除开本身一个小的还有一个大的所以是多两个；</p><p>……</p><p>发现每次新增多出正方形个数都是Min（i，j）</p></blockquote><p>二、算长方形个数</p><p>首先基础小学生公式（我都忘了，小学生都不如）</p><blockquote><p>长方形个数 = 矩形个数 - 正方形个数</p></blockquote><p>所以算矩形个数出来，减就可以了</p><p>类似求正方形个数一样，固定矩形右下角(i,j),显然此时矩形个数为i*j.</p><blockquote><p>假设i，j是格子的行和列，</p><p>初始1 x 1时有1个矩形；</p><p>基于1 x 1下1 x 2时多2个，2 x 1时多2个，2 x 2时多4个；</p><p>基于上述个数下1 x 3时多3个，3 x 1时多3个，2 x 3时多6个，3 x 2时多6个，3 x 3时多9个；</p><p>…….</p><p>发现每次新增多出矩形个数都是i*j</p></blockquote><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;  //函数min(I,J)返回两数中较小得那个数using namespace std;int main(){long long n,m,i,j,sum=0,sum1=0;cin&gt;&gt;n&gt;&gt;m;for(i=1;i&lt;=n;i++){  for(j=1;j&lt;=m;j++){    sum+=min(i,j);    sum1+=i*j;  }}cout&lt;&lt;sum&lt;&lt;" "&lt;&lt;sum1-sum&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>吐血了，小学生的题解代码都看不懂，好不容易找了个看的懂得，现在这么卷了嘛。这个路还很长，慢慢填坑吧！</p></blockquote><h1 id="例2：P2089-烤鸡"><a href="#例2：P2089-烤鸡" class="headerlink" title="例2：P2089 烤鸡 "></a>例2：<a href="https://www.luogu.com.cn/problem/P2089">P2089 烤鸡 </a></h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>暴力枚举或者深度优先搜索；</p><h2 id="暴力美学-歪解"><a href="#暴力美学-歪解" class="headerlink" title="暴力美学(歪解)"></a>暴力美学(歪解)</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span>  </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">,</span>g<span class="token punctuation">,</span>h<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>in<span class="token punctuation">,</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      cin<span class="token operator">&gt;&gt;</span>in<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>a<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>a<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>b<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>b<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>c<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>c<span class="token operator">++</span><span class="token punctuation">)</span>              <span class="token punctuation">{</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>d<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>d<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>d<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                      <span class="token keyword">for</span> <span class="token punctuation">(</span>e<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>e<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>e<span class="token operator">++</span><span class="token punctuation">)</span>                      <span class="token punctuation">{</span>                          <span class="token keyword">for</span> <span class="token punctuation">(</span>f<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>f<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>f<span class="token operator">++</span><span class="token punctuation">)</span>                          <span class="token punctuation">{</span>                              <span class="token keyword">for</span> <span class="token punctuation">(</span>g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>g<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>g<span class="token operator">++</span><span class="token punctuation">)</span>                              <span class="token punctuation">{</span>                                  <span class="token keyword">for</span><span class="token punctuation">(</span>h<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>h<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>h<span class="token operator">++</span><span class="token punctuation">)</span>                                  <span class="token punctuation">{</span>                                      <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                                      <span class="token punctuation">{</span>                                          <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                                          <span class="token punctuation">{</span>                                              <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token operator">+</span>d<span class="token operator">+</span>e<span class="token operator">+</span>f<span class="token operator">+</span>g<span class="token operator">+</span>h<span class="token operator">+</span>i<span class="token operator">+</span>j<span class="token operator">==</span>in<span class="token punctuation">)</span>                                              <span class="token punctuation">{</span>                                                  x<span class="token operator">++</span><span class="token punctuation">;</span>                                              <span class="token punctuation">}</span>                                          <span class="token punctuation">}</span>                                      <span class="token punctuation">}</span>                                  <span class="token punctuation">}</span>                              <span class="token punctuation">}</span>                          <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>a<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>a<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>b<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>b<span class="token operator">++</span><span class="token punctuation">)</span>          <span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>c<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>c<span class="token operator">++</span><span class="token punctuation">)</span>              <span class="token punctuation">{</span>                  <span class="token keyword">for</span> <span class="token punctuation">(</span>d<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>d<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>d<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                      <span class="token keyword">for</span> <span class="token punctuation">(</span>e<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>e<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>e<span class="token operator">++</span><span class="token punctuation">)</span>                      <span class="token punctuation">{</span>                          <span class="token keyword">for</span> <span class="token punctuation">(</span>f<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>f<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>f<span class="token operator">++</span><span class="token punctuation">)</span>                          <span class="token punctuation">{</span>                              <span class="token keyword">for</span> <span class="token punctuation">(</span>g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>g<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>g<span class="token operator">++</span><span class="token punctuation">)</span>                              <span class="token punctuation">{</span>                                  <span class="token keyword">for</span><span class="token punctuation">(</span>h<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>h<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>h<span class="token operator">++</span><span class="token punctuation">)</span>                                  <span class="token punctuation">{</span>                                      <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                                      <span class="token punctuation">{</span>                                          <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                                          <span class="token punctuation">{</span>                                              <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token operator">+</span>d<span class="token operator">+</span>e<span class="token operator">+</span>f<span class="token operator">+</span>g<span class="token operator">+</span>h<span class="token operator">+</span>i<span class="token operator">+</span>j<span class="token operator">==</span>in<span class="token punctuation">)</span>                                              <span class="token punctuation">{</span>                                                  cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>e<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>f<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>g<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>h<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                                                  cout<span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>                                              <span class="token punctuation">}</span>                                          <span class="token punctuation">}</span>                                      <span class="token punctuation">}</span>                                  <span class="token punctuation">}</span>                              <span class="token punctuation">}</span>                          <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment">//so beautiful!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="深度优先搜索（正解）"><a href="#深度优先搜索（正解）" class="headerlink" title="深度优先搜索（正解）"></a>深度优先搜索（正解）</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;bits/stdc++.h&gt;using namespace std;int s,flag=0,sum=0;//flag判断是否有解,sum方案总数 int nice[11],ans[20000][11]; void dfs(int dep,int total){//dep代表当前放第几种配料，total代表当前的配料和 if(dep==11){//若放到最后一个格子 if(total==s){//若所有配料质量之和达到美味程度 flag=1;sum++; for(int j=1;j&lt;=10;j++)//存储当前方案 ans[sum][j]=nice[j];}return;}else{for(int i=1;i&lt;=3;i++){//当前这种配料有三种放法 if(total+i&gt;s) break;else{nice[dep]=i;//存储 dfs(dep+1,total+i);//搜索下一种配料 nice[dep]=0;}}}}int main(void){cin&gt;&gt;s;//输入 dfs(1,0);if(flag==1){cout&lt;&lt;sum&lt;&lt;endl;//输出总数 for(int i=1;i&lt;=sum;i++){//输出全部方案 for(int j=1;j&lt;=10;j++){cout&lt;&lt;ans[i][j]&lt;&lt;" ";}cout&lt;&lt;endl;}}else if(flag==0){//若无解 cout&lt;&lt;0&lt;&lt;endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="例3：P1618三连击"><a href="#例3：P1618三连击" class="headerlink" title="例3：P1618三连击"></a>例3：<a href="https://www.luogu.com.cn/problem/P1618">P1618三连击</a></h1><p>STL中的next_permutation和prev_permutation计算排列组合关系的算法</p><p><a href="https://blog.csdn.net/qian2213762498/article/details/79683905">【用法总结】C++ STL中 next_permutation函数的用法_荷叶田田-CSDN博客_next_permutation</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int a[10]={0,1,2,3,4,5,6,7,8,9};int main(){    int A,B,C,h=0;    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;    int t=A*B*C;    A=t/A;    B=t/B;    C=t/C;    do{        if((100*a[1]+10*a[2]+a[3])*A==(100*a[4]+10*a[5]+a[6])*B&amp;&amp;(100*a[1]+10*a[2]+a[3])*A==(100*a[7]+10*a[8]+a[9])*C)//如果符合比例；        {            cout&lt;&lt;a[1]&lt;&lt;a[2]&lt;&lt;a[3]&lt;&lt;" "&lt;&lt;a[4]&lt;&lt;a[5]&lt;&lt;a[6]&lt;&lt;" "&lt;&lt;a[7]&lt;&lt;a[8]&lt;&lt;a[9]&lt;&lt;endl;//输出            h++;        }    }while(next_permutation(a+1,a+10));//STL中的下一个排列函数；    if(h==0) cout&lt;&lt;"No!!!";//没有解输出NO；    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈2</title>
      <link href="/2021/12/31/za-tan/za-tan-2/"/>
      <url>/2021/12/31/za-tan/za-tan-2/</url>
      
        <content type="html"><![CDATA[<h1 id="记21年底这一天的感触"><a href="#记21年底这一天的感触" class="headerlink" title="记21年底这一天的感触"></a>记21年底这一天的感触</h1><p>​        年底了，又是各种各样的亲戚会面时，餐馆聚餐闲聊，这家南京理工大学的闺女已经考研上岸了、那家哈工大的儿子准备考研了，特别是还有印象中并不深刻的儿时玩伴地质大学毕业今年考武大的研了，结果未揭晓。祝愿他能够成功上岸吧！</p><p>​        在哪里如坐针毡，该怎么说我呢？在家长眼里，读硕士就意味着高工资，意味着改变了命运！其实在我的眼里，粗浅的理解就是硕士去半打工，半学习，只不过老板是导师罢了，但是硕士的高学历在这个社会上的作用远比学历是本科的来的重要，读一个连名字都没有听说过的大学就是没有读一个985、211高校有出息，累了呀，躺平了都还是无法避免去被比较，卷是社会生产力进步的核心动力吗？</p><p>​        是三年的工作经验重要？还是奋力一搏试图翻身上岸？有UP主说，这取决于个人，对比考研成功的同学来说，up主本人认为，即便是自己考研失败了，也还是有着独属于自己的那份收获，现在通过工作累积的经验，恰逢站在直播兴起的风口，仍然有着属于自己人生的精彩。别人的经历始终只能作为参考，帮助我更好的去做出有利于我的决定，可是站在人生的分叉路口，我究竟又该怎么决定呢？</p><p>​        又是颓废的一天!</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文字符串</title>
      <link href="/2021/12/29/hui-wen-zi-fu-chuan/"/>
      <url>/2021/12/29/hui-wen-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="回文字串"><a href="#回文字串" class="headerlink" title="回文字串"></a>回文字串</h1><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>突破口：回文串特性，正着读反着读都一样</p><p>转化成求最长公共自序列的问题</p><p>正序与倒序“公共”的部分就是我们回文的部分，如果把正序与倒序公共的部分减去你就会惊奇的发现剩余的字符就是你所要添加的字符，也就是所求的正解</p><p>分析样例：ab3bd，样例倒序：db3ba</p><p>把ad，da加起来成回文串就是adb3bda，所以这个问题就可以转化成了求最长公共自序列的问题，将字符串的长度减去它本身的“回文的”（最长公共自序列）字符便是正解</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>最长公共自序列问题是个经典的dp问题，</p><p>最容易想到的方法就是开个二维数组dp【i】【j】，i，j分别代表两种状态；</p><p>那么我们的动态转移方程应该就是if(str1[i] == str2[j]) dp[i][j]=dp[i-1][j-1]+1;</p><pre class="line-numbers language-none"><code class="language-none">Else dp[i][j] = max(dp[i-1][j], dp[i][j-1];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依此即可解出最长公共自序列，用字符串长度减去即是正解</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        str2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str1<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//做一个逆序的字符串数组 </span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//最长公共自序列匹配 </span>            <span class="token keyword">else</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//不匹配的往下匹配状态 </span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n<span class="token operator">-</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//字符串长度减去匹配出的最长公共自序列的值 </span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                                        <span class="token comment">//即需要添加的字符数 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可这并不是最优解法，只是能ac这道题而已 若是将内存限制改为2MB呢？</p><p>不过，没关系，正常开一个5001*5001的数组一定会爆掉的，此时你是不是在思考另一种解决方案来优化一下空间复杂度，如果我可以把它用一维数组代替二维数组中的状态量是不是也可以求出正解</p><p>没错。它真的能求出正解；</p><p>如果你仔细研究一下就会发现每次搜索到str1的第i个元素的时候，数组dp【】【】真正使用到的元素仅仅是dp【i】【j】和dp【i-1】【k】（0 &lt;= k &lt;= n(n = strlen(str1)）</p><p>即dp【】【】的第一下标从0–&gt;i-2就没有用处了，因此我们可以开辟两个滚动数组来降低空间复杂度</p><p>Dp1【】用来记录当前状态，dp2【】用来记录之前的状态也就相当于刚才的dp【i-1】【j】</p><p>动态转移方程应该这么表达if(str1[i] == str2[i]) dp1[j] = dp2[j-1] +1;</p><p>Else dp1[j] = max(dp1[j-1], dp2[j]);</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdlib&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> dp1<span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp2<span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//此处用两个滚动数组记录，一个记录之前的状态，一个记录此时的状态</span><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">5001</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//freopen("palindrome.in", "r", stdin);</span>    <span class="token comment">//freopen("palindrome.out", "w", stdout);</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        str2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str1<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                <span class="token comment">//做一个逆序的字符串数组 </span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                                     dp1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">//“发现”匹配就记录</span>            <span class="token keyword">else</span>                dp1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//不匹配就匹配后面的状态 </span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>dp2<span class="token punctuation">,</span> dp1<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dp1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//记录之前的状态“滚动”匹配 </span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n<span class="token operator">-</span>dp1<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//字符串长度减去匹配出的最长公共自序列的值                          </span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                            <span class="token comment">//即需要添加的字符数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="竞赛中常见状态说明"><a href="#竞赛中常见状态说明" class="headerlink" title="竞赛中常见状态说明"></a>竞赛中常见状态说明</h1><h2 id="AC-Accept-通过"><a href="#AC-Accept-通过" class="headerlink" title="AC: Accept 通过"></a>AC: Accept 通过</h2><p>出现这个图标的时候表示在本测试点中你的输出是正确的，拿到了本测试点的满分</p><h2 id="WA-Wrong-Answer-答案错误"><a href="#WA-Wrong-Answer-答案错误" class="headerlink" title="WA: Wrong Answer 答案错误"></a>WA: Wrong Answer 答案错误</h2><p>出现这个图标的时候表示在本测试点中你的输出是错误的，在本测试点中未拿到任何分数</p><h2 id="RE-Runtime-Error-运行时错误"><a href="#RE-Runtime-Error-运行时错误" class="headerlink" title="RE: Runtime Error 运行时错误"></a>RE: Runtime Error 运行时错误</h2><p>这表明你的程序在运行过程中因为出锅而崩溃了，通常可能是访问非法内存等问题，出现这个提示但你还能过样例的话，大概率是数组没开够，仔细检查一下。</p><h2 id="CE-Complie-Error-编译错误"><a href="#CE-Complie-Error-编译错误" class="headerlink" title="CE: Complie Error 编译错误"></a>CE: Complie Error 编译错误</h2><p>这表明你的程序没有通过编译。如果在本地编译可以通过的话，检查一下提交语言是不是选对了或是有没有引用一些不该引用的东西</p><h2 id="TLE-Time-Limit-Exceeded-超出时间限制"><a href="#TLE-Time-Limit-Exceeded-超出时间限制" class="headerlink" title="TLE: Time Limit Exceeded 超出时间限制"></a>TLE: Time Limit Exceeded 超出时间限制</h2><p>这表明你的程序运行所用的时间超过了测试点的规定时间。出现这个提示时一般表明你的算法的时间复杂度不够优秀，需要优化；但也有可能程序深入死循环无法自拔</p><h2 id="MLE-Memory-Limit-Exceeded-超出内存限制"><a href="#MLE-Memory-Limit-Exceeded-超出内存限制" class="headerlink" title="MLE: Memory Limit Exceeded 超出内存限制"></a>MLE: Memory Limit Exceeded 超出内存限制</h2><p>这表明你的程序所调用的内存大小超出了测试点的内存限制，一般表明你的算法的空间复杂度不是很优秀，比如像NOIP铺地毯中什么百万级二维数组的失智做法什么的，好好优化一下~</p><h2 id="PC-Partially-Correct-部分正确"><a href="#PC-Partially-Correct-部分正确" class="headerlink" title="PC: Partially Correct 部分正确"></a>PC: Partially Correct 部分正确</h2><p>这个提示信息一般会在题目启用Special Judge的时候可能会返回，代表着你得到了本测试点的部分分数。一般情况有两个：</p><ol><li>你的答案正确，格式错误，Special Judge给你送了点良心分</li><li>你的答案中间有一部分是正确的，根据题目要求，Special Judge 给你返回了你这一部分答案的分数</li></ol><p>这个时候一定要仔细查看Special Judge 给你返回的信息，仔细检查，距离AC就不远啦！</p><h2 id="OLE-Output-Limit-Exceeded-超出输出限制"><a href="#OLE-Output-Limit-Exceeded-超出输出限制" class="headerlink" title="OLE: Output Limit Exceeded 超出输出限制"></a>OLE: Output Limit Exceeded 超出输出限制</h2><p>表示你的程序出现了 <strong>大 量</strong> 的输出，一般还是程序在输出过程中深陷死循环无法自拔，好好检查一下代码逻辑~</p><h2 id="UKE-Unknown-Error-未知错误"><a href="#UKE-Unknown-Error-未知错误" class="headerlink" title="UKE: Unknown Error 未知错误"></a>UKE: Unknown Error 未知错误</h2><p>这个时候一般是评测姬锅了，如果多次提交都是出现这个提示的话，赶快联系网站的管理员鸭~</p><p>文章引用</p><ul><li><a href="https://www.zhihu.com/question/371296221">在信息学竞赛中AC、WA、RE、CE、TLE、MLE、PE、OLE分别是什么意思？ - 知乎 (zhihu.com)</a></li><li>[P1435 <a href="https://www.luogu.com.cn/problem/solution/P1435">IOI2000] 回文字串 / [蓝桥杯 2016 省] 密码脱落 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《希望之线》--东野圭吾</title>
      <link href="/2021/12/25/za-tan/xi-wang-zhi-xian/"/>
      <url>/2021/12/25/za-tan/xi-wang-zhi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="《希望之线》"><a href="#《希望之线》" class="headerlink" title="《希望之线》"></a>《希望之线》</h1><p>以前曾看过东野圭吾的《白夜行》、《解忧杂货店》、《嫌疑人x的献身》等书，现在看完《希望之线》不由得感慨，确实还是这种比较有深度的书籍看完比那些网文、爽文看完来的更加回味无穷！</p><blockquote><p>《希望之线》的故事围绕咖啡馆店主花冢弥生遇害一案的调查展开，在此过程中，刑警松宫脩平与嫌疑人汐见行伸也逐渐揭开关于家人的真相。情节的发展既在意料之外又在情理之中，看似无关的人物之间有着错综复杂的关系。</p></blockquote><p>人们因奇妙的缘分相遇，他们各自的命运因无形的羁绊而缠绕连结。</p><p>这是一本重新定义家庭的疗愈之书。东野圭吾采用群像式手法描绘出汐见行伸、松宫脩平、花冢弥生和几个家庭命运的交织，随着案件的推进逐步引领读者展开对“家”和“生命”的思考。</p><p>你曾想过自己为什么来到这个世界吗？家有千百种形式，爱才是连结彼此的要素。</p><p>无论人们因何而生，只要来到这个世界，就会拥有最有温度、最有力量的守候——这是《希望之线》想要传递给读者的信念。也许我们注定无法掌控我们与世界初遇的机缘，但我们依然可以选择用温暖的目光点亮前路，满怀希望面对生活。</p><h2 id="案件回溯："><a href="#案件回溯：" class="headerlink" title="案件回溯："></a>案件回溯：</h2><p><strong>弥生</strong>，是一个独自经营咖啡馆的老板，为人善良、温柔，住在附近的女人都会常常来她的店里光顾，不仅仅是她的甜点饮品味道好，还因为她这个人很好相处，即使是遇到故意刁难的客人，她也能妥善处理好问题，可就是这样一个善良的人，在前不久却被杀害了，而种种迹象表明，她是被人谋杀的！</p><p>在松宫的调查中发现，弥生在近一个月开始健身和减肥，所以，<strong>这个案件最大嫌疑的人应该是这两个男性</strong>：一个是十几年未曾联系，却在最近见了面的前夫——棉贯；另外一个就是这家咖啡店唯一的男常客——行伸。于是，松宫抓着这两条线索，展开了调查。</p><p>棉贯与弥生离婚，是因为一直无法生育，但两个人的婚姻关系，其实很美满，并没有任何所谓仇恨的苗头，而且棉贯也已经有了长期稳定的同居女友，但离婚十年的夫妻，突然见面只为了汇报一下近况，显然是不合常理的，但却也没有足够的证据证明他与这个案件有关联。</p><p>至于行伸呢？除了他与女儿的关系异常外，似乎只是个正常的追求者。到底哪里出了问题呢？</p><blockquote><p>Tips：松宫是主线一和主线二连接的关键，主线一是搜查官松宫追查的案件，主线二是松宫在追查案件中慢慢推进的，最后在主线一的影响下，勇敢面对可能是将自己抛弃的父亲。</p></blockquote><h2 id="主线一："><a href="#主线一：" class="headerlink" title="主线一："></a>主线一：</h2><p>故事开始，怜子和行伸的两个孩子在地震中不幸遇难，夫妻两个的生活意外的陷入了灰暗，而为了走出中年丧子的阴霾，两人通过体外受精的方式——女儿<strong>萌奈</strong>出生了，然而从小到大，萌奈一直背负着“连哥哥、姐姐的也要一起活回来”的包袱。平静的生活，后来因怜子重病死去，产生了裂痕，随着萌奈逐渐长大，父女两个却无法很好的沟通，后来在“看手机事件”中，所有的问题终于爆发了，结果是父女两人的关系变得一发不可收拾，越来越疏远，甚至是相互躲避，很少见面，甚至连吃饭也不在一起，交集越来越少。直到有一天，刑警松宫敲开家门，行伸好像卷入一场谋杀案……</p><h2 id="主线二："><a href="#主线二：" class="headerlink" title="主线二："></a>主线二：</h2><p>亚矢子有一位伟大的父亲，花费了半生时间去照顾瘫痪在床的母亲，并挽救了母亲家濒临破产的店铺，让其发展壮大。可就是这样的父亲，却也逃不出最终走向死亡的命运。</p><p>在一次探望父亲结束，一直合作的律师给<strong>亚矢子</strong>看了父亲的遗嘱。令人意外的是，在遗嘱中父亲竟然说他还有一个亲生儿子，并清楚地标明了住址和姓名。<strong>难道父亲曾经出轨，且在外留有私生子？</strong>可父亲并非一个能做出这样事情的人，是不是其中有什么误会呢？亚矢子决定联系一下对方，找出答案。</p><p>松宫接到了一个陌生女人的电话，对方声称自己的父亲还在世，而且目前正罹患重病在医院，希望与他相见，并了解一下情况。可当松宫打电话给母亲问询到底是什么情况时，她却闭口不言。自己的父亲是否还在世？为什么当初离开了自己和妈妈？时隔多年为什么又来相认……一个一个的谜团，让松宫陷入了沉思。</p><p><strong>Tips</strong>：主要人物汇总一下，免得后面人物太多看麻了，有时间在画人物关系图吧。</p><ul><li>花冢<strong>弥生</strong>：被害者，主线一中有关人物</li><li>汐见<strong>行伸</strong>：疑似弥生追求者，主线一有关人物</li><li>怜子：行伸妻子，主线一有关人物</li><li>萌奈：行伸“女儿”，主线一有关人物</li><li><strong>棉贯</strong>：弥生的前夫，主线一有关人物</li><li>多由子：棉贯女友，主线一有关人物</li><li><strong>松宫</strong>脩平：刑警，主线一二有关人物</li><li>亚矢子：松宫同父异母的姐姐，主线二有关人物</li><li>芳原正美：亚矢子母亲，</li><li>森本弓江：正美密友，</li><li>真次：亚矢子父亲，</li><li>克子：松宫母亲，</li></ul><p>为什么好多东西我没写太清楚而是留下一个个问题咧？想知道啊，那就去看书吧，哈哈，或者找我聊天，我给你讲讲也行，芜湖！</p><p>最感动的三个瞬间：（涉嫌剧透）</p><p>1.多由子欺骗棉贯自己怀孕的那段</p><p>2.萌奈和行伸释怀那段</p><p>3.松宫和真次见面那段</p><blockquote><p>东野圭吾在书中说“就算无法对自己很重要的人见面，只要一想到两人被无形的细线相连，就已经足够幸福，无论那条线有多长，都令人充满希望。”</p><p>这条连接父母与孩子之间的希望之线就是爱。</p></blockquote><p>本文引用：</p><ul><li><a href="https://baike.baidu.com/tashuo/browse/content?id=a642e1fb4a1d59392c6f81f0&amp;lemmaId=56410488&amp;fromLemmaModule=pcBottom&amp;lemmaTitle=%E5%B8%8C%E6%9C%9B%E4%B9%8B%E7%BA%BF">一本关于的爱的侦探小说——东野圭吾2021年新作《希望之线》</a></li><li><a href="https://baijiahao.baidu.com/s?id=1701895336577961886&amp;wfr=spider&amp;for=pc">《希望之线》：东野圭吾催泪新作，比《解忧杂货铺》更打动人心 </a></li><li><a href="https://baijiahao.baidu.com/s?id=1702520991947498842&amp;wfr=spider&amp;for=pc">《希望之线》：越爱越折磨，为什么爱让我们筋疲力尽？</a></li></ul><h1 id="《白夜行》"><a href="#《白夜行》" class="headerlink" title="《白夜行》"></a>《白夜行》</h1><blockquote><p>由于母亲与自己家当铺雇的人在家里偷情，<strong>桐原亮司</strong>跑到废弃大楼的通风道里玩耍，却看到了父亲对自己的好友雪穗实施侵害的不堪一幕，扭曲的惊惧与愤怒使得11岁的他用长剪刀刺死了自己的父亲，之后西本雪穗的母亲及“母亲的情人”也“意外死亡”，随后她被优雅独居的唐泽礼子收养。没有了完整家庭的少男和少女，在惨剧发生后度过了平静的七年，然而，桐原亮司发现当年的案子还是有人在查，而且，已经开始怀疑到自己和<strong>唐泽雪穗</strong>身上了。没有家庭温暖的二人，为了不让自己的罪行被发现，用尽各种手段把自己身边的亲人、朋友一一除掉。</p><p>这一切的起因竟是少女的母亲由于家庭窘迫，为了钱硬逼着自己的女儿出卖肉体，幼年不幸的经历，让雪穗的心灵从此失去了阳光；而亮司基于各种复杂的情愫，一直暗中帮助雪穗报复迫害她的人，同时也帮她一步步铲除一切妨碍她成功的障碍。 </p><p>最终桐原亮司为了让警察不追查到雪穗，用借用跳楼的冲击力用剪刀自尽，而雪穗面对桐原亮司的尸体，转身离去，一次也没有回头。</p></blockquote><p>一个跨越十九年的案件及其所牵涉到的其它案件，全部从其他参与者或者旁观者的角度来描述。对男女主人公的了解和认识几乎全部从每个相关人员的故事中获得。</p><p>小说最后一句写道：“只见雪穗正沿扶梯上楼，背影犹如白色的幽灵。她一次都没有回头。”桐原亮司的无悔付出，已经到了“粉身碎骨浑不怕”的地步，就连雪穗的绝情，也在计划当中。然而这两个双手沾满罪恶的人，却是一对互相依靠的苦难的灵魂。男女主角最大的愿望，就是手牵手在阳光下散步，然而这对于他们却是永远无法企及的奢望。他们只能在用彼此的光亮照耀下的黑夜艰难前行，为了生存，他们付出了无法偿还的代价。</p><p>小说的结局，亮司从雪穗华丽的新店楼梯上跃下。当警察笹垣问雪穗:“这个人是谁？”雪穗像人偶般面无表情地答道：“我不知道。”这是小说中在那场杀人案后亮司和雪穗唯一一次出现在同一场景中，却是生死两隔。“只见雪穗正沿扶梯上楼，背影犹如白色的影子。”“她一次都没有回头。”亮司一直在为雪穗的幸福付出，甚至宁愿用自己的生命成就雪穗的新生，而雪穗却对亮司的死如此冷漠，多数读者认为雪穗并不爱亮司。小说中有一段雪穗的独白，这是她第一次袒露自己的内心，“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。”是亮司的爱代替了太阳照亮了雪穗的世界，绝望的亮司纵身一跃结束了自己的生命，雪穗的太阳熄灭了，她和亮司早已合为一体，亮司的死带走了雪穗的灵魂，让她的背影“犹如白色的影子”。她没有回头，不是不爱，而是太爱，为了死去的亮司她绝不能泄露心底的痛楚和悲伤，从此她只能在黑暗中孤独前行。</p><p>有时间再整理吧，溜了溜了！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qtday02</title>
      <link href="/2021/12/20/qtday02/qtday02/"/>
      <url>/2021/12/20/qtday02/qtday02/</url>
      
        <content type="html"><![CDATA[<h1 id="QT笔记"><a href="#QT笔记" class="headerlink" title="QT笔记"></a>QT笔记</h1><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><ul><li>QMainWindow 类生成的窗口自带菜单栏、工具栏和状态栏，中央区域还可以添加多个控件，常用来作为应用程序的主窗口；</li><li>QDialog 类生成的窗口非常简单，没有菜单栏、工具栏和状态栏，但可以添加多个控件，常用来制作对话框。</li><li>QWidget 类，它的用法非常灵活，既可以用来制作窗口，也可以作为某个窗口上的控件。</li></ul><blockquote><p>实际开发中，制作应用程序的主窗口可以用 QMainWindow 或者 QWdiget；制作一个提示信息的对话框就用 QDialog 或 QWidget；如果暂时无法决定，后续可能作为窗口，也可能作为控件，就选择 QWidget。</p></blockquote><p><img src="/Qtday02/1632193B2-0.gif" alt="img"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QWidget widget;//定义一个按钮，它位于 widget 窗口中QPushButton But("按钮控件",&amp;widget);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>信号发送者是 But 按钮对象，要发送的信号是“按钮被点击”，可以用 QPushButton 类提供的 clicked() 信号函数表示；信号的接收者是 widget 主窗口对象，“窗口关闭”作为信号对应的槽，可以用 QWidget 类提供的 close() 函数表示。</p><p>用 connect() 函数将 But 按钮的 clicked() 信号函数和 widget 窗口的 close() 槽函数关联起来，</p><p> connect() 函数指定信号函数和槽函数的语法格式是<code>&amp;+函数所在类+函数名</code>。</p><p>实现代码如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">connect(&amp;But, SIGNAL(clicked()), &amp;widget, SLOT(close()));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如此就实现了“按下按钮会关闭窗口”的功能。</p><h2 id="QLabel文本框"><a href="#QLabel文本框" class="headerlink" title="QLabel文本框"></a>QLabel文本框</h2><h1 id="课程讲解"><a href="#课程讲解" class="headerlink" title="课程讲解"></a>课程讲解</h1><p>demo.pro文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QT       += core gui   //core核心库，gui图形界面greaterThan(QT_MAJOR_VERSION, 4): QT += widgets//让代码在老版本和新版本中兼容TARGET = demo03  //项目名称TEMPLATE = app# The following define makes your compiler emit warnings if you use# any feature of Qt which has been marked as deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if you use deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0SOURCES += \        main.cpp \        mainwindow.cppHEADERS += \        mainwindow.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;namespace Ui {//防止重复命名class MainWindow;//主界面}class MainWindow : public QMainWindow{    Q_OBJECTpublic:    explicit MainWindow(QWidget *parent = 0);    ~MainWindow();private:    Ui::MainWindow *ui;};#endif // MAINWINDOW_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include "mainwindow.h"#include &lt;QApplication&gt;int main(int argc, char *argv[]){    QApplication a(argc, argv);//继承自wiget类的    MainWindow w;//s    w.show();//显示界面    return a.exec();//事件循环}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>信号参数要比槽多，反之不可以；</p><p>信号也可以和信号连接</p><p>信号与槽可以一对一，一对多，多对一</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux02</title>
      <link href="/2021/12/19/linux/linux02/"/>
      <url>/2021/12/19/linux/linux02/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux02"><a href="#Linux02" class="headerlink" title="Linux02"></a>Linux02</h1><p>常用命令：</p><table><thead><tr><th>命令</th><th>作用（英文）</th><th>作用（中文）</th></tr></thead><tbody><tr><td>ls</td><td>list</td><td>查看当前文件夹下的内容，类似Dos中的dir</td></tr><tr><td>pwd</td><td>print work directory</td><td>查看当前所在文件夹</td></tr><tr><td>cd [目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>touch [文件名]</td><td>touch</td><td>如果文件不存在，新建文件</td></tr><tr><td>mkdir [目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>rm [文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><h3 id="运行-python-程序"><a href="#运行-python-程序" class="headerlink" title="运行 python 程序"></a>运行 python 程序</h3><ul><li><p>创建一个 test.py 文件</p></li><li><p>在文件第一行指定 python 命令的路径</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>添加执行权限</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chmod +x test.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>直接运行 py 文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./test.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络01</title>
      <link href="/2021/12/19/ji-suan-ji-ji-chu/ji-suan-ji-wang-luo-01/"/>
      <url>/2021/12/19/ji-suan-ji-ji-chu/ji-suan-ji-wang-luo-01/</url>
      
        <content type="html"><![CDATA[<h1 id="网络介绍及分类"><a href="#网络介绍及分类" class="headerlink" title="网络介绍及分类"></a>网络介绍及分类</h1><h2 id="网络介绍"><a href="#网络介绍" class="headerlink" title="网络介绍"></a>网络介绍</h2><p>计算机网络是由通信介质将地理位置不同的且相互独立的计算机连接起来，实现数据通信与资源共享</p><h2 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h2><p>按拓扑结构分类</p><ul><li>总线型：最初的的网络类型，效率低且容易故障</li><li>环形：同一时间只有两台有网络令牌的计算机能够通信</li><li>星型：中央节点压力大，容易单点故障，但是网络利用率较高</li><li>网型：现代设备采用的类型</li></ul><p>按地域分类：参照物不同，类型不同</p><ul><li>局域网（LAN）：一个公司或一个家庭</li><li>域域网（MAN）：一个区或一个城市或一个国家</li><li>广域网（WAN）：一个国家或全世界</li></ul><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><ul><li>交换机：负责组建局域网，研究的是MAC地址（出厂时厂商做这块网卡的时放入的48位，由厂商地址和全球唯一的编号组成）</li><li>路由器：负责组建广域网，研究的是IP地址</li></ul><h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>同轴电缆：</p><p>双绞线：两根具有绝缘保护层的铜导线按一定密度互相搅在一起，传输中辐射出的电波互相抵消，有效降低信号干扰程度</p><p>分为屏蔽双绞线和非屏蔽两种，理论最大传输100米，但建议不要超过90米.</p><p>也可以按传输速度分为5类（百兆）和超5类（两者之间），6类（千兆）</p><p>光纤：易折，但传输速率快</p><p>单模光纤：只能传输一种模式的光，传输距离远，单模外套一般为黄色</p><p>多模光纤：可传多种模式的光，但传输距离比较近，一般为橘红色</p><p>电磁信号，蓝牙等</p><p>通常目前使用的是光纤远距离传输，到家里转双绞线</p><h1 id="ISO与OSI"><a href="#ISO与OSI" class="headerlink" title="ISO与OSI"></a>ISO与OSI</h1><h2 id="ISO介绍"><a href="#ISO介绍" class="headerlink" title="ISO介绍"></a>ISO介绍</h2><p>一个全球性的非政府组织，负责绝大多数领域（军工，石油，船舶等垄断行业）的标准化活动，中国国家技术监督局代表中国作为正式成员加入ISO</p><p>由于不同厂商计算机采用的不同的通信协议，所以当时不同厂商之间的计算机无法通信。1977年Bachman在ANSI（美国国家标准协会）早期会议中提交了他的七层模型（），该唯一草案后来经过完善后1978年发布诞生了OSI七层模型。</p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><h1 id="TCP-IP四层"><a href="#TCP-IP四层" class="headerlink" title="TCP/IP四层"></a>TCP/IP四层</h1><p>OSI体系概念清楚，理论完整，但是过于庞大，复杂且不实用，由技术人员自己开发的TCP/IP协议栈获得了更广泛的应用。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/image-20210904101100846.png" alt="image-20210904101100846"></p><ul><li><p>网络接口层：操作系统中的设备驱动程序和计算机中对应的网络接口卡。就是处理物理接口细节的电缆，交换机，传输介质等。有ARP协议和RARP协议</p></li><li><p>网际层：处理分组在网络中的活动。网络层协议中包括IP协议，ICMP协议，IGMP协议</p></li><li><p>传输层：主要是提供两台主机上的应用程序提供端到端的通信。有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）</p></li><li><p>应用层：负责处理特定的应用程序细节。几乎各种不同的TCP/IP实现都会提供下面这些通用的应用程序：</p></li></ul><p>Tenlnet远程登录</p><p>FTP文件传输协议</p><p>SMYTP简单邮件传送协议</p><p>SNMP简单网络管理协议</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/image-20210904112658031.png" alt="image-20210904112658031"></p><h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><p>它们都使用相同的网络层协议（IP），但向应用层提供的确实完全不同的服务。TCP提供的是面向连接的可靠的字节流服务。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>传输控制协议，面向连接的协议</p><p>面向连接就两个使用TCP的应用（通常为一个server，一个client）在彼此交换数据前建立一个TCP连接（三次握手），进行一对一传输</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/image-20210904120630973.png" alt="image-20210904120630973"></p><p>传输完成后（四次挥手）</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/image-20210904121029932.png" alt="image-20210904121029932"></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>用户数据报协议，无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。UDP报文没有可靠性保障，顺序保证，和流量控制字段，可靠性差。但正是因为它的可控制选项比较少，数据传输过程中延迟低，数据传输效率高，并其可以一对一，一对多传输，多对多交互通信</p><p>一般视频，音频，既时消息都是udp</p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><ol><li>tcp面向连接，udp无连接</li><li>tcp是可靠服务。它通过校检和重传控制，序号标识，滑动窗口，确认应答，丢包的重发控制，乱序的顺序控制等来传输的数据，能够无差错，不丢失，不重复切按序到达。而udp则是尽力交付，不保证可靠交付。</li><li>udp具有较好的实时性，工作效率较高，适用高速传输和实时性较高的通信和广播通信</li><li>tcp只能端到端，而udp不是</li><li>tcp对系统资源要求较多，udp相反</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈</title>
      <link href="/2021/12/19/za-tan/za-tan/"/>
      <url>/2021/12/19/za-tan/za-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><h1 id="记录一次大无语的事件"><a href="#记录一次大无语的事件" class="headerlink" title="记录一次大无语的事件"></a>记录一次大无语的事件</h1><p>就最开始入门前端的时候我是看的尚硅谷的视频，当时配置的VScode后陪伴了我很长一段时间，后来有一天点击VScode的文图标运行不了，卸载也卸载不了，显示找不到文件，重新安装也不行，百度了一番操作也没啥用，最后只好另下载WebStorm来使用，今天重命名了一个文件改成了之前的名字，code的图标就突然的亮了，欸，好了！原来是我安装的文件的位置被我改了名字，吐血！</p><h1 id="干了这碗鸡汤！"><a href="#干了这碗鸡汤！" class="headerlink" title="干了这碗鸡汤！"></a>干了这碗鸡汤！</h1><p><strong>生活的理想，就是为了理想的生活</strong></p><p><strong>只有拥抱浪潮，才能屹立于浪潮之巅</strong></p><h1 id="非常眼熟的代码"><a href="#非常眼熟的代码" class="headerlink" title="非常眼熟的代码"></a>非常眼熟的代码</h1><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;bits/stdc++.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>老是在题解和别人的代码看见这行代码，忍不住搜了一下原来这是一个万能头文件</p><p>它包括了c++中所有的头文件，下面贴下源码中看看它包含了多少头文件吧！</p><pre class="line-numbers language-none"><code class="language-none">#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>平时学习的时候最好还是自己打上头文件！而且用这个可能会慢一点，当然如果想偷懒还是可以的哈哈!</p><h1 id="Linux切换root失败"><a href="#Linux切换root失败" class="headerlink" title="Linux切换root失败"></a>Linux切换root失败</h1><p>在Linux中我以普通用户的身份登录以后，想要配置网络，修改一个文件，结果没有权限保存，强制都没用，然后切换root用户，报错鉴定故障，困扰我好久，甚至想重装系统了都，结果偶然发现是我命令用错了，切换root用户的命令是su不是sudo！</p><p>su和sudo的区别是:</p><p>　　1) su的密码是root的密码，而sudo的密码是用户的密码；</p><p>　　2) su直接将身份变成root，而sudo是以用户登录后以root的身份运行命令，不需要知道root密码.</p><p>感谢：<a href="https://blog.csdn.net/u013371163/article/details/60469114">Linux - root初始密码设置_北岛知寒-CSDN博客_root默认密码</a></p><p>初始密码我是设置了，结果无语了，命令作用搞错了</p><h1 id="Linux网络问题"><a href="#Linux网络问题" class="headerlink" title="Linux网络问题"></a>Linux网络问题</h1><p>之前看到尚硅谷比较老旧的教程，别人装虚拟机的时候就是选择的NAt模式，还专门分了一期视频讲的，nat模式最好，他也用的这个模式装的，没啥问题，但是到我就是网络有问题，去按照百度的各种方法一个一个的试都不管用，足足折腾几个小时都没得用，后来换了桥接模式，瞬间就通了，啥都没调，吐血了，教程是那么说没错，可是实际操作就是有很大的不同，所以还是实践比较重要！</p><h1 id="无限恐怖，个人电脑被控制了！"><a href="#无限恐怖，个人电脑被控制了！" class="headerlink" title="无限恐怖，个人电脑被控制了！"></a>无限恐怖，个人电脑被控制了！</h1><p>又是一个安静的晚上，一个人坐在床上敲电脑，我本来在浏览着网页，打开着IDE和word，完成今天培训的日志，结果，鼠标突然不受控制的移动起来，因为我在双手在敲代码，不排除误触触控面板的可能，所以我用触控面板调节回鼠标以后继续敲，结果她她她居然又动了，，期间我使用鼠标尝试移动，结果被拖回去了，楞了一会儿，看着鼠标自动操作，而我双手已经离开电脑的我，楞了一下后说时迟那时快，很快啊，反应过来第一件事就是Ctrl+S，接着一套<strong>强制关机</strong>的组合拳，过了一会儿以后，开机重启几秒钟以后我第一件事首先就是<strong>断网</strong>，然后去把远程协助和远程桌面全部关掉设置为<strong>不允许连接到这台计算机</strong>，然后<strong>卸载可疑程序</strong>，因为我之前弄过一些破解的软件使用，也曾有下载过流氓软件，不过流氓软件解决以后反正没跳出来骚扰过我以后就没管了，随后ctrl+alt+delete<strong>关闭可疑进程</strong>，接着就是<strong>修改用户的密码</strong>为复杂的数字+大小写字母+符号，接着打开<strong>管家清理插件和全盘杀毒</strong>！进行到这里作为普通用户已经尽力了，做好物理备份，如果实在不行只能重装了！</p><p>意外收获：</p><p>1.win+r输入MRT可以清理恶意文件！</p><p>2.安全模式的进入：</p><ul><li>无法启动Windows时：长按强制关机，然后开机到有启动徽标界面时再强制关机，这样3次以后进入自动修复界面点击疑难解答—高级选项—启动设置—点击重启—按数字4或F4键进入安全模式</li><li>可以进入Windows时：长按shift并点击重启后出现自动修复界面和无法启动时的操作一样进入安全模式</li></ul><p>3.注册表有着好多之前删除的软件确还存在的情况，顺手清了几个认识的，不认识的不敢动蛤。</p><p>总结：</p><blockquote><p>计划对一些公有文件进行云备份，对私有文件进行物理备份，这样不管出现什么情况，至少还能兜底！</p></blockquote><h1 id="最近追番"><a href="#最近追番" class="headerlink" title="最近追番"></a>最近追番</h1><p>双城之战</p><p>斗破苍穹之三年之约</p><p>某科学的超电磁炮</p><p>魔法禁书目录</p><p>冰雪奇缘</p><p>冰雪奇缘2</p><p>国王排名</p><h4 id="秒速五厘米"><a href="#秒速五厘米" class="headerlink" title="秒速五厘米"></a>秒速五厘米</h4><p>​        对于无从选择而倍感恐惧的心理现象，之所以会无从选择，主要还是因为不了解自己到底想要做什么，想成为一个怎样的人。</p><p>​        自己来说，真正重要的东西是什么？不想放弃的东西是什么？无论如何都想要的的东西又是什么？</p><p>正是因为不了解这些事情，才会出现找不到方向的情况。</p><p>​        明明其他人都已经爽快的做出了抉择，为何自己却无法决定呢？</p><p>​        如果用一个比较陈腐的说法来解释的话，那就是“没有一个类似梦想的梦想”</p><p>时间带着鲜明的恶意，从我身上慢慢流走；</p><p>我深知，</p><p>这以后的将来，</p><p>我们不可能一起走过。</p><p>对于命途多舛的人生，</p><p>以及渺茫的时间，</p><p>阻挡在我们之间的这一事实，</p><p>我们无可奈何……</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法解决迷宫问题</title>
      <link href="/2021/12/17/shu-ju-jie-gou-yu-suan-fa/hui-su-suan-fa-jie-jue-mi-gong-wen-ti/"/>
      <url>/2021/12/17/shu-ju-jie-gou-yu-suan-fa/hui-su-suan-fa-jie-jue-mi-gong-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;//typedef enum { false, true } bool;#define ROW 5#define COL 5//假设当前迷宫中没有起点到终点的路线bool find = false;//回溯算法查找可行路线void maze_puzzle(char maze[ROW][COL], int row, int col, int outrow, int outcol);//判断 (row,col) 区域是否可以移动bool canMove(char maze[ROW][COL], int row, int col);//输出行走路线void printmaze(char maze[ROW][COL]);int main(){    char maze[ROW][COL] = {    {'1','0','1','1','1'},    {'1','1','1','0','1'},    {'1','0','0','1','1'},    {'1','0','0','1','0'},    {'1','0','0','1','1'} };    maze_puzzle(maze, 0, 0, ROW - 1, COL - 1);    if (find == false) {        printf("未找到可行线路");    }    return 0;}//(row,col) 表示起点，(outrow,outcol)表示终点void maze_puzzle(char maze[ROW][COL], int row, int col, int outrow, int outcol) {    maze[row][col] = 'Y'; // 将各个走过的区域标记为 Y    //如果行走至终点，表明有从起点到终点的路线    if (row == outrow &amp;&amp; col == outcol) {        find = true;        printf("成功走出迷宫,路线图为：\n");        printmaze(maze);        return;    }    //尝试向上移动    if (canMove(maze, row - 1, col)) {        maze_puzzle(maze, row - 1, col, outrow, outcol);        //如果程序不结束，表明此路不通，恢复该区域的标记        maze[row - 1][col] = '1';    }    //尝试向左移动    if (canMove(maze, row, col - 1)) {        maze_puzzle(maze, row, col - 1, outrow, outcol);        //如果程序不结束，表明此路不通，恢复该区域的标记        maze[row][col - 1] = '1';    }    //尝试向下移动    if (canMove(maze, row + 1, col)) {        maze_puzzle(maze, row + 1, col, outrow, outcol);        //如果程序不结束，表明此路不通，恢复该区域的标记        maze[row + 1][col] = '1';    }    //尝试向右移动    if (canMove(maze, row, col + 1)) {        maze_puzzle(maze, row, col + 1, outrow, outcol);        //如果程序不结束，表明此路不通，恢复该区域的标记        maze[row][col + 1] = '1';    }}//判断 (row,col) 区域是否可以移动bool canMove(char maze[ROW][COL], int row, int col) {    //如果目标区域位于地图内，不是黑色区域，且尚未行走过，返回 true：反之，返回 false    return row &gt;= 0 &amp;&amp; row &lt;= ROW - 1 &amp;&amp; col &gt;= 0 &amp;&amp; col &lt;= COL - 1 &amp;&amp; maze[row][col] != '0' &amp;&amp; maze[row][col] != 'Y';}//输出可行的路线void printmaze(char maze[ROW][COL]) {    int i, j;    for (i = 0; i &lt; ROW; i++) {        for (j = 0; j &lt; COL; j++) {            printf("%c ", maze[i][j]);        }        printf("\n");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2021/12/17/shu-ju-jie-gou-yu-suan-fa/tan-xin-suan-fa/"/>
      <url>/2021/12/17/shu-ju-jie-gou-yu-suan-fa/tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote><p>每一步都力求最大限度地解决问题，每一步都选择的是当前最优的解决方案，这种解决问题的算法就是<strong>贪心算法</strong>。</p></blockquote><p>举例：</p><p>假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std; //当前的钱库，面值以及对应数量int single_money[7] = {1,2,5,10,20,50,100};int number_money[7] = {2,5,0,3,4,0,4}; //每种面值使用贪心算法后需要使用的张数int count[7] = {}; int total_count; int tanxin(int money){if (money &gt;= 0)   //考虑一下输入规范的问题{for (int i = 6; i &gt;= 0; i--){count[i] = min(number_money[i],money/single_money[i]);money = money - count[i]*single_money[i];}return 0;}else{return money;}}  int main(int argc,char** argv){int money;cout&lt;&lt;"Please input the amount of money:";cin&gt;&gt;money;if(! tanxin(money)){cout&lt;&lt;"贪心最优结果为："&lt;&lt;endl;cout&lt;&lt;"100元："&lt;&lt;count[6]&lt;&lt;"张"&lt;&lt;endl;cout&lt;&lt;"50元："&lt;&lt;count[5]&lt;&lt;"张"&lt;&lt;endl;cout&lt;&lt;"20元："&lt;&lt;count[4]&lt;&lt;"张"&lt;&lt;endl;cout&lt;&lt;"10元："&lt;&lt;count[3]&lt;&lt;"张"&lt;&lt;endl;cout&lt;&lt;"5元："&lt;&lt;count[2]&lt;&lt;"张"&lt;&lt;endl;cout&lt;&lt;"2元："&lt;&lt;count[1]&lt;&lt;"张"&lt;&lt;endl;cout&lt;&lt;"1元："&lt;&lt;count[0]&lt;&lt;"张"&lt;&lt;endl;}else{cout&lt;&lt;"Ops, Wrong number~";}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>贪心算法注重的是每一步选择最优的解决方案（又称“局部最优解”），并不关心整个解决方案是否最优。</p><p>贪心算法常用来解决<strong>部分背包问题</strong>。</p><blockquote><p>在限定条件下，如何从众多物品中选出收益最高的几件物品，这样的问题就称为背包问题</p><p>根据不同的限定条件，背包问题还可以有更细致的划分：</p><ul><li>0-1 背包问题：每件物品都不可再分，要么整个装入背包，要么放弃，不允许出现类似“将物品的 1/3 装入背包”的情况；</li><li>部分背包问题：每件物品是可再分的，即允许将某件物品的一部分（例如 1/3）放入背包；</li><li>完全背包问题：挑选物品时，每件物品可以选择多个，也就是说不限物品的数量。</li><li>多重背包问题：每件物品的数量是有严格规定的，比如物品 A 有 2 件，物品 B 有 3 件。</li></ul></blockquote><h2 id="贪心算法和动态规划算法"><a href="#贪心算法和动态规划算法" class="headerlink" title="贪心算法和动态规划算法"></a>贪心算法和动态规划算法</h2><p>💡 <strong>贪心选择性质是贪心算法与动态规划算法的主要区别</strong>：</p><ul><li>在动态规划算法中，每步所做的选择依赖于相关子问题的解，所以只有解决相关子问题后，才能做出选择。</li><li>而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择，再去解做出这个选择后产生的相应的子问题。也就是说，<strong>贪心算法所做的贪心选择可以依赖过去所做过的选择，但绝不依赖将来所作的选择，也不依赖子问题的解</strong>。</li></ul><p>⭐ 正是由于这种差别，<strong>动态规划算法是<code>自底向上</code>的，而贪心算法是<code>自顶向下</code>的</strong>，以迭代的方式做出相继的贪心选择，<strong>每做一次贪心选择，就将所求问题简化为规模更小的子问题</strong>。</p><h1 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h1><p><strong>【题目】</strong>给你很多形如 <code>[start, end]</code> 的闭区间，请你设计一个算法，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p><pre class="line-numbers language-none"><code class="language-none">int intervalSchedule(int[][] intvs) {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p><p><strong>【解题思路】</strong>正确的思路其实很简单，可以分为以下三步：</p><ol><li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li><li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li><li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int intervals[][2]={{1,3},{3,6},{2,4}};void sort(){for(int i=0;i&lt;3;i++){int temp[][1]={0};if (intervals[i][1]&gt;intervals[i+1][1]){temp[0][0] = intervals[i][0];temp[0][1] = intervals[i][1];intervals[i][0] = intervals[i+1][0];intervals[i][1] = intervals[i+1][1];intervals[i+1][0] = temp[0][0] ;intervals[i+1][1] = temp[0][1] ;}}}int main(){sort();//先给区间升序排列int count = 0; // 最大的不相交区间的数量int x_end = intervals[0][1]; // 从最小的 end 开始    for(int i=1;i&lt;3;i++){        int start = intervals[i][0];        int end = intervals[0][i];            if(start &gt;= x_end){                count ++;                x_end = end;            }    }    cout&lt;&lt;count&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本文引用来源：</p><ul><li><p><a href="https://blog.csdn.net/misayaaaaa/article/details/72789998">贪心算法——C++实现经典案例——初级_MISAYAONE的博客-CSDN博客_贪心算法c++</a></p></li><li><p><a href="http://c.biancheng.net/">http://c.biancheng.net/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*寻路算法</title>
      <link href="/2021/12/16/shu-ju-jie-gou-yu-suan-fa/a-xun-lu-suan-fa/"/>
      <url>/2021/12/16/shu-ju-jie-gou-yu-suan-fa/a-xun-lu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="A-寻路算法"><a href="#A-寻路算法" class="headerlink" title="A*寻路算法"></a>A*寻路算法</h1><p>迷宫寻路算法中A*算法比BFS更高效一点！</p><p>简化搜索区域</p><ol><li>一个记录下所有被考虑来寻找最短路径的方块（称为open 列表）</li><li>一个记录下不会再被考虑的方块（成为closed列表）</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;queue&gt;#include&lt;iterator&gt;using namespace std;#define MAX   10int fx[4] = { -1,1,0,0 }, fy[4] = { 0,0,-1,1 };int sx, sy, ex, ey;struct _NODE{int x;int y;//节点坐标int dis;//节点的步数int f;//权值};int cmp( _NODE a,  _NODE b){return a.f &lt; b.f;}int weight(int x, int y)//高级算法不会   来个曼哈顿距离计算{return abs(x - sx) + abs(y - sy) + abs(x - ex) + abs(y - ey);}int fun_a(int maze[9][9]){_NODE  sNode;sNode.x = sx;sNode.y = sy;sNode.dis = 0;sNode.f= weight(sNode.x, sNode.y);maze[sNode.x][sNode.y] = 1;list&lt;_NODE&gt;  mylist;mylist.push_back(sNode);//添加头结点while (!mylist.empty()){    mylist.sort(cmp);//按节点权值大小进行排序sNode = mylist.front();mylist.pop_front();//从链表中取出节点maze[sNode.x][sNode.y] = 1;//并将访问状态设为1if (sNode.x == ex &amp;&amp; sNode.y == ey){return sNode.dis;}for (int i = 0;i &lt; 4;i++){if (sNode.x + fx[i] &lt; 9 &amp;&amp; sNode.x + fx[i] &gt;= 0 &amp;&amp; sNode.y + fy[i] &lt; 9 &amp;&amp;sNode.y + fy[i] &gt;= 0 &amp;&amp; maze[sNode.x + fx[i]][sNode.y + fy[i]] == 0)   //判断路径是否可走{_NODE  tp;tp.x = sNode.x + fx[i];tp.y = sNode.y + fy[i];tp.f = weight(tp.x, tp.y); //计算节点的权值tp.dis = sNode.dis + 1;  //更新步数mylist.push_back(tp);}   }}return 0;}int main(){int t;cin &gt;&gt; t;while (t--){int maze[9][9] ={ { 1,1,1,1,1,1,1,1,1 },{ 1,0,0,1,0,0,1,0,1 },{ 1,0,0,1,1,0,0,0,1 },{ 1,0,1,0,1,1,0,1,1 },{ 1,0,0,0,0,1,0,0,1 },{ 1,1,0,1,0,1,0,0,1 },{ 1,1,0,1,0,1,0,0,1 },{ 1,1,0,1,0,0,0,0,1 },{ 1,1,1,1,1,1,1,1,1 },};cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;cout &lt;&lt; fun_a(maze) &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_learn_day01</title>
      <link href="/2021/12/16/qtday01/qtday01/"/>
      <url>/2021/12/16/qtday01/qtday01/</url>
      
        <content type="html"><![CDATA[<h1 id="QT是什么？"><a href="#QT是什么？" class="headerlink" title="QT是什么？"></a>QT是什么？</h1><p>QT一个跨平台的 C++ 开发库，主要用来开发图形用户界面（Graphical User Interface，GUI）程序</p><p>总起来说，Qt 主要用于桌面程序开发和嵌入式开发。</p><p>用 Qt 来开发 Windows 桌面程序有以下优点：</p><ul><li>简单易学：Qt 封装的很好，几行代码就可以开发出一个简单的客户端，不需要了解 Windows API。</li><li>资料丰富：资料丰富能够成倍降低学习成本，否则你只能去看源码，关于 DirectUI、Htmlayout、aardio 的资料就很少。</li><li>漂亮的界面：Qt 很容易做出漂亮的界面和炫酷的动画，而 MFC、WTL、wxWidgets 比较麻烦。</li><li>独立安装：Qt 程序最终会编译为本地代码，不需要其他库的支撑，而 Java 要安装虚拟机，C# 要安装 .NET Framework。</li><li>跨平台：如果你的程序需要运行在多个平台下，同时又希望降低开发成本，Qt 几乎是必备的。</li></ul><p>用qt来开发手机移动应用开发</p><p>QML 类似于网页设计的 HTML，是一种标记语言，我们可以借助 CSS 对它进行美化，也可以借助 <a href="http://c.biancheng.net/js/">JavaScript</a> 进行交互。QML 只能用来进行界面设计和人机交互，也就是只能胜任 UI 部分，在底层仍然需要调用 C++ 编写的组件来完善功能，比如访问数据库、网络通信、多线程多进程、文件读写、图像处理、音频视频处理等都离不开 C++。目前的大型开发一般是以 C++ 为主、QML 为辅的开发模式。</p><p>使用 QML 开发界面主要有以下几个优点：</p><ul><li>QML 非常灵活，可以做出非常炫酷的效果，例如 QQ、360、迅雷等都不在话下。</li><li>QML 是标记语言，见名知意，非常容易编写和阅读，大大提高了开发和维护效率。</li><li>QML 界面简洁大气，有很多动画，适合移动端。</li><li>不同平台下的 QML 使用相同的渲染机制，界面效果一致，不会随操作系统的不同而变化。</li></ul><h1 id="QT学习第一步：初步了解"><a href="#QT学习第一步：初步了解" class="headerlink" title="QT学习第一步：初步了解"></a>QT学习第一步：初步了解</h1><ul><li>qt的软件安装：网上教程很多</li><li>了解它的目录结构：<a href="http://c.biancheng.net/view/3866.html">解密Qt安装目录的结构 (biancheng.net)</a></li></ul><p><a href="http://c.biancheng.net/qt/">Qt</a> 不是凭空产生的，它是基于现有工具链打造而成的，它所使用的编译器、链接器、调试器等都不是自己的，Qt 官方只是开发了上层工具。</p><ul><li>GNU工具： MinGW 可以生成 Windows 里面的 exe 程序和 dll 链接库</li><li>qmake 工具：核心的项目构建工具，可以生成跨平台的 .pro 项目文件，并能依据不同操作系统和编译工具生成相应的 Makefile，用于构建可执行程序或链接库。而Boost C++ Libraries、<a href="http://c.biancheng.net/opencv/">OpenCV</a>、LLVM、Clang 等是用 CMake 脚本。</li></ul><h2 id="QT涉及术语名词"><a href="#QT涉及术语名词" class="headerlink" title="QT涉及术语名词"></a>QT涉及术语名词</h2><p>makefile：它是一个生成脚本，生成器make根据规范的makefile自动生成目标程序或文件</p><p>debug：调试版本链接的也是 Debug 版本的库文件，比如 libQt5Guid.a/Qt5Guid.dll，库文件的简短名（不含扩展名）都是以 d 结尾的，Debug 库通常都比较大 。</p><p>release：链接的通常就是 Release 版本的库文件，Release 版本库文件名字比 Debug 版本库文件少一个字母 d ，如 libQt5Gui.a/Qt5Gui.dll，而且 Release 版本库一般都比 Debug 版本小很多，运行效率也高很多。</p><p>Dynamic Link 即动态链接，Static Link 即静态链接。</p><blockquote><h4 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h4><p>目标程序通常都不是独立个体，生成程序时都需要链接其他的库，要用到其他库的代码。对于多个程序同时运行而言，内存中就可能有同一个库的多个副本，占用了太多内存而干的活差不多。</p><p>为了优化内存运用效率，引入了动态链接库（Dynamic Link Library），或叫共享库（Shared Object）。使用动态链接库时，内存中只需要一份该库文件，其他程序要使用该库文件时，只要链接过来就行了。由于动态库文件外置，链接到动态库的目标程序相对比较小，因为剥离了大量库代码，而只需要一些链接指针。</p><p>使用动态库，也意味着程序需要链接到如 *.dll 或 *.so 文件，得提前装好动态库文件，然后目标程序才能正常运行。</p><h4 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h4><p>静态库就是将链接库的代码和自己编写的代码都编译链接到一块，链接到静态库的程序通常比较大，但好处是运行时依赖的库文件很少，因为目标程序自己内部集成了很多库代码。</p><h4 id="库文件后缀"><a href="#库文件后缀" class="headerlink" title="库文件后缀"></a>库文件后缀</h4><p>Linux/Unix 系统里静态库扩展名一般是 .a，动态库扩展名一般是 .so 。Windows 系统里 VC 编译器用的静态库扩展名一般是 .lib，动态库扩展名一般是 .dll 。</p><p>MinGW 比较特殊，是将 GNU 工具集和链接库从 Linux/Unix 系统移植到 Windows 里， 有意思的情况就出现了，MinGW 使用的静态库扩展名为 .a ，而其动态库扩展名则为 .dll， .a 仅在生成目标程序过程中使用，.dll 则是在目标程序运行时使用。</p></blockquote><p>Explicit Linking 即显式链接，Implicit Linking 即隐式链接，这两种都是动态链接库的使用方式。</p><blockquote><p>动态链接库通常都有其导出函数列表， 告知其他可执行程序可以使用它的哪些函数。可执行程序使用这些导出函数有两种方式：一是在运行时使用主动加载动态库的函数，Linux 里比如用 dlopen 函数打开并加载动态库，Windows 里一般用 LoadLibrary 打开并加载动态库，只有当程序代码执行到这些函数时，其参数里的动态库才会被加载，这就是显式链接。显式链接方式是在运行时加载动态库，其程序启动时并不检查这些动态库是否存在。</p><p>隐式链接是最为常见的，所有的编译环境默认都是采用隐式链接的方式使用动态库。隐式链接会在链接生成可执行程序时就确立依赖关系，在该程序启动时，操作系统自动会检查它依赖的动态库，并一一加载到该程序的内存空间，程序员就不需要操心什么时候加载动态库了。比如 VC 编译环境，链接时使用动态库对应的 .lib 文件（包含动态库的导出函数声明，但没有实际功能代码），在 .exe 程序运行前系统会检查依赖的 .dll，如果找不到某个动态库就会出现报错的对话框</p></blockquote><p><strong>MinGW 是将动态库的导出函数声明放在了 .a 文件里，程序运行依赖的动态库也是 .dll 。</strong></p><h1 id="QT学习第二步：第一个项目"><a href="#QT学习第二步：第一个项目" class="headerlink" title="QT学习第二步：第一个项目"></a>QT学习第二步：第一个项目</h1><p><img src="/QTday01/image-20211216105205179.png" alt="image-20211216105205179"></p><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>创建项目（注意取消创建界面）</p><p>main.cpp 文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include "mainwindow.h" //自己创建的要用""#include &lt;QApplication&gt; //qt提供的&lt;&gt;int main(int argc, char *argv[]){    QApplication a(argc, argv);    MainWindow w;//MainWindow 是自定义的类，继承自 QMainWindow 主窗口类    w.show();//默认情况下，Qt 提供的所有组件（控件、部件）都是隐藏的，不会自动显示。通过调用 MainWindow 类提供的 show() 方法，w 窗口就可以在程序运行后显示出来。    return a.exec();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建项目时，定义了一个继承自 QMainWindow 的主窗口类，并起名为 MianWindow，该类的定义部分位于 mainwindow.h 头文件中，实现部分位于 mainwindow.cpp 源文件中。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;class MainWindow : public QMainWindow{    Q_OBJECT//本质是一个已定义好的宏，所有需要“信号和槽”功能的组件都必须将 Q_OBJECT 作为 private 属性成员引入到类中。public:    MainWindow(QWidget *parent = 0);//带参的构造函数：QWidget 是所有组件的基类，借助 parent 指针，可以为当前窗口指定父窗口。    ~MainWindow();};//mainwindow.cpp#endif // MAINWINDOW_H#include "mainwindow.h"MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent){}MainWindow::~MainWindow(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编码实现简易的窗口界面"><a href="#编码实现简易的窗口界面" class="headerlink" title="编码实现简易的窗口界面"></a>编码实现简易的窗口界面</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QLabel&gt;      // 引入 QLable 文件框组件的头文件class MainWindow : public QMainWindow{    Q_OBJECTpublic:    MainWindow(QWidget *parent = 0);    ~MainWindow();private:    QLabel *lab;        // 定义一个私有的 QLabel 指针对象};//mainwindow.cpp#endif // MAINWINDOW_H#include "mainwindow.h"MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent){    // 创建一个 QLable 对象    this-&gt;lab = new QLabel("Hello,World!",this);}MainWindow::~MainWindow(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/QTday01/image-20211216111915053.png" alt="image-20211216111915053"></p><p>这样就通过编码实现的包含文本框的窗口，而字体和大小都是可以通过代码改变的，这也是第一个qt程序！收工，芜湖！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红包算法</title>
      <link href="/2021/12/15/shu-ju-jie-gou-yu-suan-fa/hong-bao-suan-fa/"/>
      <url>/2021/12/15/shu-ju-jie-gou-yu-suan-fa/hong-bao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="红包算法"><a href="#红包算法" class="headerlink" title="红包算法"></a>红包算法</h1><p>微信抢红包想来大家都知道，发出一个固定金额的红包，由若干个人来抢，需要满足哪些规则？</p><ul><li>所有人抢到金额之和等于红包金额，不能超过，也不能少于。</li><li>每个人至少抢到一分钱。</li><li>要保证所有人抢到金额的几率相等。</li></ul><blockquote><p>普通法：每次针对剩余总金额做一次随机，随机值就是第一个人的数值。这个算法的好处是完全随机，坏处是极有可能造成前人抢的太多，后人太少。例如，100元分给10个人，第一个人在0-100随机，均值为50。而第二个人的均值只剩25，之后是12.5。</p></blockquote><p>普通法和二倍均值法各有缺点，来看看《算法之旅》中提到的没有实现的线段切割法。</p><h1 id="线段切割法"><a href="#线段切割法" class="headerlink" title="线段切割法"></a>线段切割法</h1><p>把红包总金额M想象成一条很长的线段，而每个人抢到的金额，则是这条主线段所拆分出的若干子线段。</p><p>每个人抢到的金额也就是子线段的长度由“切割点”来决定。当 N 个人一起抢红包的时候，就需要确定 N-1 个切割点。因此，我们需要做 N-1 次随机运算，以此确定 N-1 个切割点。随机的范围区间是（1， M-1）。</p><p>当所有切割点确定以后，子线段的长度也随之确定。这样每个人来抢红包的时候，只需要顺次领取与子线段长度等价的红包金额即可。</p><p>这就是线段切割法的思路。在这里需要注意以下两点：</p><ol><li>当随机切割点出现重复，如何处理。</li><li>如何尽可能降低时间复杂度和空间复杂度。</li></ol><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;time.h&gt; #include &lt;stdlib.h&gt;using namespace std;//线段切割法    无保底//iTotalGold总金额    iNum份数    iBaseGold保底金额void cutline(int iTotalGold, int iNum){    if (iNum &gt; iTotalGold)  {    return;  }  if (iNum == iTotalGold)  {    for (int i = 0; i &lt; iNum; ++i)      cout &lt;&lt; 1 &lt;&lt; " ";    cout &lt;&lt; endl;    return;  }  std::set&lt;int&gt; setGold;  for (int i = 0; i &lt; iNum-1; ++i)  {    while (1)    {      int iPos = rand() % iTotalGold;      if (setGold.find(iPos) == setGold.end())      {        setGold.insert(iPos);        break;      }    }  }  cout &lt;&lt; "线段切割法(无保底):" &lt;&lt; endl;  int iPreLine = 0;  for (auto &amp;it : setGold)  {    cout &lt;&lt; it - iPreLine &lt;&lt; " ";    iPreLine = it;  }  cout &lt;&lt; iTotalGold - iPreLine &lt;&lt; " ";  cout &lt;&lt; endl;}int main(void){srand((unsigned int)time(0));//初始化种子为随机值    int iTotalGold = 100;    int iNum = 10;     int iBaseGold = 5;    cutline(iTotalGold, iNum);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现缺点是由于过于随机导致有可能有小概率造成某个人分配过多，不过可以做一个保底就欧克啦！</p><h1 id="双倍随机法"><a href="#双倍随机法" class="headerlink" title="双倍随机法"></a>双倍随机法</h1><p>每次随机的时候，取0-每个人平均金额的2倍进行随机。</p><p>微信团队公布的算法好像就是这个。</p><p>例如：100个人分10分，每次随机都是0-100/10*2去随机，基本可以保证每个人平均在10左右，是相当平均的算法。不过需要注意最后几个人可能已经不足20的情况。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt; #include &lt;iterator&gt;using namespace std;//双倍随机法//iTotalGold总金额    iNum份数    iBaseGold保底金额void twobase(int iTotalGold, int iNum, int iBaseGold){  if (iNum *iBaseGold &gt; iTotalGold)  {    cout &lt;&lt; "保底太多 " &lt;&lt; iBaseGold &lt;&lt; endl;    return;  }  std::vector&lt;int&gt; veGold(iNum, iBaseGold);  iTotalGold -= iNum*iBaseGold;  int iBaseTmp = iTotalGold / iNum * 2;  for (int i = 0; i &lt; iNum - 1; ++i)  {    if (iTotalGold == 0)      break;    int iTmp = 0;    if (iTotalGold &gt;= iBaseTmp){    iTmp = rand()%iBaseTmp;    }    else      iTmp = rand() % iTotalGold;    veGold[i] += iTmp;    iTotalGold -= iTmp;  }  veGold[iNum - 1] = iTotalGold;  cout &lt;&lt; "双倍随机法:" &lt;&lt; endl;  copy(veGold.begin(), veGold.end(), ostream_iterator&lt;int&gt;(cout, " "));  cout &lt;&lt; endl;}int main(){    int iTotalGold = 100;    int iNum = 10;     int iBaseGold = 5;    twobase(iTotalGold, iNum, iBaseGold);      return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本文参考文章：</p><ul><li><a href="https://blog.csdn.net/weixin_38754349/article/details/108271392">最全解密微信红包随机算法(含代码实现)_weixin_38754349的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/zhanglu_1024/article/details/118889172">抢红包算法–四种抢红包算法对比（附源码）_zhanglu_1024的博客-CSDN博客_抢红包算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列的互相实现</title>
      <link href="/2021/12/14/shu-ju-jie-gou-yu-suan-fa/zhan-he-dui-lie-de-hu-xiang-shi-xian/"/>
      <url>/2021/12/14/shu-ju-jie-gou-yu-suan-fa/zhan-he-dui-lie-de-hu-xiang-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列的相互实现"><a href="#栈和队列的相互实现" class="headerlink" title="栈和队列的相互实现"></a>栈和队列的相互实现</h1><blockquote><p>栈（stack）：先进后出，后进先出。限定在表尾进行插入删除的线性表。</p><p>队列（queue）：先进先出，后进后出。限定在表头删除，在表尾插入的线性表。</p></blockquote><p>那么如何用栈来实现队列和如何用队列来实现栈的数据结构呢？</p><h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p>单个栈肯定无法实现队列，所以至少应该用两个栈来试现队列。</p><h3 id="入队："><a href="#入队：" class="headerlink" title="入队："></a>入队：</h3><ul><li>数据栈：每次有新元素来时，先把存放的元素弹入辅助栈，再把新元素压入数据栈底；</li><li>辅助栈：等待新元素进入数据栈以后依次弹出元素压入数据栈中；</li></ul><p>根据这两个栈的功能，不管是数据栈中是否有元素存在，新元素都会被沉到栈底中，实现入队的功能。</p><h3 id="出队："><a href="#出队：" class="headerlink" title="出队："></a>出队：</h3><p>由于在入队时，通过数据栈与辅助栈的交换，实现了后加入的元素沉在栈底，先进入的元素保留在栈顶，直接通过出栈弹出即可</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class StackImplQueue {    // 数据栈    private Stack&lt;Integer&gt; stack;    // 辅助栈    private Stack&lt;Integer&gt; aux;    StackImplQueue() {        stack = new Stack&lt;&gt;();        aux = new Stack&lt;&gt;();    }    // 入队--通过数据栈与辅助栈相互交换，保证新加入的元素沉在数据栈底    public void enqueue(Integer e) {        while (!stack.isEmpty()) {            aux.push(stack.pop());        }        stack.push(e);        while(!aux.isEmpty()){            stack.push(aux.pop());        }    }    // 出队--弹出数据栈元素    public Integer dequeue(){        return stack.pop();    }    // 查看队头元素    public Integer peek(){        return stack.peek();    }    // 是否为空    public boolean isEmpty(){        return stack.isEmpty();    }    public static void main(String[] args) {        StackImplQueue queue = new StackImplQueue();        queue.enqueue(1);        System.out.println(queue.peek());        queue.enqueue(2);        System.out.println(queue.peek());        queue.enqueue(3);        System.out.println(queue.peek());        System.out.println("=============");        System.out.println(queue.dequeue());        System.out.println(queue.dequeue());        System.out.println(queue.dequeue());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><h3 id="入栈："><a href="#入栈：" class="headerlink" title="入栈："></a>入栈：</h3><p>入栈的元素要在队头，而队列入队的元素在队尾，只需<strong>让队头至队尾前的其它所有元素依次出队再入队，直至在队尾新加入的元素被移到队头，也即实现了让新压入的元素保留在栈顶</strong>。</p><h3 id="出栈："><a href="#出栈：" class="headerlink" title="出栈："></a>出栈：</h3><p>由于在入栈时保证队列中新加入队尾的元素被移到了队头，出栈只需弹出队头元素即可</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QueueImplStack</span> <span class="token punctuation">{</span>    <span class="token comment">// 定义队列</span>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">QueueImplStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 入栈--在队尾加入元素后,让其他元素按顺序出队再入队，保持新加入的元素永远在队头</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 出栈--将队尾前的其它所有元素出队再入队，直至队尾元素移到队头</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 查看栈顶元素--即队头元素</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">QueueImplStack</span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueueImplStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="C-版代码"><a href="#C-版代码" class="headerlink" title="C++版代码"></a>C++版代码</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//用栈实现队列#include&lt;stack&gt;#include&lt;iostream&gt;using namespace std;class queue{public:stack&lt;int&gt; dataStack;//数据栈 stack&lt;int&gt; auxStack;//辅助栈//入队，通过辅助栈让新元素沉于栈底void push(int x) {while(!dataStack.empty()){auxStack.push(dataStack.top());dataStack.pop();}dataStack.push(x);while(!auxStack.empty()){        dataStack.push(auxStack.top());        auxStack.pop();    }}    // 出队--弹出数据栈元素    int outqueue(){    int temp = dataStack.top();    dataStack.pop();        return temp;    }    // 查看队头元素    int top(){        return dataStack.top();    }    // 是否为空    bool empty(){        return dataStack.empty();    }};int main(){queue iq;iq.push(1);cout&lt;&lt;iq.top()&lt;&lt;endl;iq.push(2);cout&lt;&lt;iq.top()&lt;&lt;endl;iq.push(3);cout&lt;&lt;iq.top()&lt;&lt;endl;cout&lt;&lt;"-------------"&lt;&lt;endl;cout&lt;&lt;iq.outqueue()&lt;&lt;endl;cout&lt;&lt;iq.outqueue()&lt;&lt;endl;cout&lt;&lt;iq.outqueue()&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//用队列实现栈#include&lt;deque&gt;#include&lt;iostream&gt;using namespace std;class stack{public:deque&lt;int&gt; de;    // 入栈--在队尾加入元素后,让其他元素按顺序出队再入队，保持新加入的元素永远在队头    void push(int x) {        de.push_front(x);        int size = de.size();        int i = 0;        while (i &lt; size - 1) {            de.push_front(de.back());            de.pop_back();            i++;        }    }    // 出栈--将队尾前的其它所有元素出队再入队，直至队尾元素移到队头    int pop() {    int temp = de.front();    de.pop_front();        return temp;    }    // 查看栈顶元素--即队头元素    int top() {        return de.front();    }    // 是否为空    bool isEmpty() {        return de.empty();    }};int main(){stack iq;iq.push(1);cout&lt;&lt;iq.top()&lt;&lt;endl;iq.push(2);cout&lt;&lt;iq.top()&lt;&lt;endl;iq.push(3);cout&lt;&lt;iq.top()&lt;&lt;endl;cout&lt;&lt;"-------------"&lt;&lt;endl;cout&lt;&lt;iq.pop()&lt;&lt;endl;cout&lt;&lt;iq.pop()&lt;&lt;endl;cout&lt;&lt;iq.pop()&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本文参考来源：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1643318">用队列实现栈，用栈实现队列，听起来有点绕，都搞懂了就掌握了精髓！ - 云+社区 - 腾讯云 (tencent.com)</a></li><li>《小灰的算法之旅》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求最大公约数</title>
      <link href="/2021/12/14/shu-ju-jie-gou-yu-suan-fa/qiu-zui-da-gong-yue-shu/"/>
      <url>/2021/12/14/shu-ju-jie-gou-yu-suan-fa/qiu-zui-da-gong-yue-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h1><p>写一段代码，求出两个整数的最大公约数，要尽量优化算法的性能。</p><blockquote><p>辗转相除法， 又名欧几里得算法（Euclidean algorithm），该算法的目的是求出两个正整数的最大公约数。它是已知最古老的算法， 其产生时间可追溯至公元前300年前。</p><p>两个数的最大公约数,将其中一个数加到另一个数上,得到的新数,其公约数不变,比如(4,6)=(4+6,6)=(4,6+2×4)=2</p></blockquote><p>解题代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt; using namespace std;int fun(int m,int n){return n ? fun(n,m%n) : m ;}int main(){int a,b;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;fun(a,b)&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一行代码解决了？太强了本文引用来源：</p><ul><li><a href="https://blog.csdn.net/qq_41575507/article/details/90752742">求最大公约数（辗转相除法）_ACfun-CSDN博客_辗转相除法求最大公约数</a></li></ul><h1 id="判断一个数是不是2的整数次幂"><a href="#判断一个数是不是2的整数次幂" class="headerlink" title="判断一个数是不是2的整数次幂"></a>判断一个数是不是2的整数次幂</h1><p>2的整数次幂有4、8、16、32等，但是把它们转化为二进制数后减1会1发现所有位都是1.</p><p>所以凡是2的整数次幂和它本身减1的结果进行与运算，其结果必然为0！</p><p>解题代码：</p><pre class="line-numbers language-none"><code class="language-none">int main(){    int a;    cin&gt;&gt;a;    if ((a&amp;a-1) == 0)    cout&lt;&lt;"yes"&lt;&lt;endl;    else    cout&lt;&lt;"no"&lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ps：时间复杂度为O（1）哦！</p><h1 id="无序数组排序后最大相邻差"><a href="#无序数组排序后最大相邻差" class="headerlink" title="无序数组排序后最大相邻差"></a>无序数组排序后最大相邻差</h1><p>1.利用桶排序的思想，先求出原数组从最小值Min到最大值Max的单位区间长度d，d=(Max-Min)/n-1。算出d的作用是为了后续确定各个桶的区间范围划分。</p><p>2.创建一个长度是N+1的数组Array，数组的每一个元素都是一个List，代表一个桶。</p><p>3.遍历原数组，把原数组每一个元素插入到新数组Array对应的桶当中，进入各个桶的条件是根据不同的数值区间。由于桶的总数量是N+1，所以至少有一个桶是空的。</p><p>4.遍历新数组Array，计算每一个空桶右端非空桶中的最小值，与空桶左端非空桶的最大值的差，数值最大的差即为原数组排序后的相邻最大差值。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static int getMaxSortedDistance(int[] array) {        // 1. 获取数组中的最大值和最小值，构建数组的长度        int max = array[0];        int min = array[0];        for (int i = 1; i &lt; array.length; i++) {            if (array[i] &gt; max) {                max = array[i];            }            if (array[i] &lt; min) {                min = array[i];            }        }        int distance = max - min;        // 如果max和min相等，说明数组所有元素都相等，返回0        if (distance == 0) {            return 0;        }        // 2. 初始化桶        int bucketNum = array.length;        Bucket[] buckets = new Bucket[bucketNum];        for (int i = 0; i &lt; bucketNum; i++) {            buckets[i] = new Bucket();        }         // 3. 遍历原始数组，确定每个桶的最大最小值        for (int i = 0; i &lt; array.length; i++) {            // 确定数组元素所属的桶小标            int index = ((array[i] - min) * (bucketNum - 1)) / distance;            if (buckets[index].min == null || buckets[index].min &gt; array[i]) {                buckets[index].min = array[i];            }            if (buckets[index].max == null || buckets[index].max &lt; array[i]) {                buckets[index].max = array[i];            }        }         // 4. 遍历桶，找到最大差值        // 这里采用临时变量leftMax,在每一轮迭代时存储当前左侧桶的最大值，        // 而两个桶之间的差值，则是buckets[i].min - leftIndex        int leftIndex = buckets[0].max;        int maxDistance = 0;        for (int i = 1; i &lt; buckets.length; i++) {            if (buckets[i].min == null) {                continue;            }            if (buckets[i].min - leftIndex &gt; maxDistance) {                maxDistance = buckets[i].min - leftIndex;            }            leftIndex = buckets[i].max;        }        return maxDistance;     }     /**     * 桶     */    private static class Bucket{        Integer min;        Integer max;    } public static void main(String[] args) {         int[] array = new int[] {2, 6, 3, 4, 5, 10, 3};//        int[] array = new int[]{0, 0, 1, 2, 3, 4, 5, 6, 12, 13, 20, 10};        // 桶排序方式        int maxSortedDistance = getMaxSortedDistance(array);        System.out.println("最大相邻差为:"+ maxSortedDistance);     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序计算机中是如何运行的</title>
      <link href="/2021/12/11/ji-suan-ji-ji-chu/cao-zuo-xi-tong-03/"/>
      <url>/2021/12/11/ji-suan-ji-ji-chu/cao-zuo-xi-tong-03/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统03"><a href="#操作系统03" class="headerlink" title="操作系统03"></a>操作系统03</h2><h2 id="程序在计算机中是如何运行的"><a href="#程序在计算机中是如何运行的" class="headerlink" title="程序在计算机中是如何运行的"></a>程序在计算机中是如何运行的</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main(void) {int a=1;printf("%p\n",&amp;a);printf("%p\n",main);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的一段程序打印出来的地址是真实的物理地址吗？<br>答案是：<br>    不是，所有这些打印出来的地址都是虚拟的，在物理内存中这些地址并不真实存在，<br>    它们最终都将由操作系统和 CPU 硬件翻译成真正的物理地址，<br>    然后才能从真实的物理位置获取该地址的值。</p><h2 id="什么是虚拟寻址（virtual-addressing）？"><a href="#什么是虚拟寻址（virtual-addressing）？" class="headerlink" title="什么是虚拟寻址（virtual addressing）？"></a>什么是虚拟寻址（virtual addressing）？</h2><p>CPU 生成虚拟地址并进行地址翻译的流程：</p><ul><li>​    CPU 通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前会先被转换成合适的物理地址，这个虚拟地址到物理地址的转换过程称为 地址翻译/地址转换（address translation）。</li><li>​    CPU 上的内存管理单元（Memory Management Unit，MMU）就是专门用来进行虚拟地址到物理地址的转换的，不过 MMU 需要借助存放在内存中的查询表，而这张表的内容正是由操作系统进行管理的。</li></ul><h2 id="为什么引入虚拟物理寻址？"><a href="#为什么引入虚拟物理寻址？" class="headerlink" title="为什么引入虚拟物理寻址？"></a>为什么引入虚拟物理寻址？</h2><p>​    真实物理寻址将全部内存信息保存的太慢，而且在进程对应的内存留在物理内存中，上下文切换时切换到特定区域，这种方式存在安全隐患，因此操作系统引入一个新的内存抽象–虚拟寻址（地址空间）</p><p>虚拟寻址的作用：<br>    当你运行一个程序也就是一个进程时，操作系统会给这个进程分配一个虚拟地址空间，该进程的虚拟地址空间，独立于其他进程的地址空间，这样就不会发生冲突。<br>    在程序中定义的栈、堆、代码段都是虚拟地址空间，它们的实际物理地址是不可见的，这样就保护了进程的安全性。</p><h2 id="为什么设计分层存储体系？"><a href="#为什么设计分层存储体系？" class="headerlink" title="为什么设计分层存储体系？"></a>为什么设计分层存储体系？</h2><p><img src="https://gitee.com/veal98/images/raw/master/img/20210415105520.png"></p><p>分层存储体系如上图所示，每个人都希望自己的计算机容量无限大，访问速度无限快，并且能永久性的存储而且不能太昂贵，可是目前的技术水平达不到，因此人们探索出分层存储体系来将这些需求拆开对应到不同的存储器上，这样计算机就拥有:</p><ul><li>若干超级快速的寄存器，但超级昂贵，且具有易失性；</li><li>若干快速的高速缓存器，但由于和CPU制作材料相同所以同样昂贵且具有易失性；</li><li>速度和价格都适中，但同样易失的内存；</li><li>低速廉价但具有非易失性的磁盘</li></ul><h2 id="程序在计算机中是如何运行的呢"><a href="#程序在计算机中是如何运行的呢" class="headerlink" title="程序在计算机中是如何运行的呢"></a>程序在计算机中是如何运行的呢</h2><p>当你双击火狐浏览器时，操作系统通过图形界面（GUI）知道你需要运行这个软件，它就会到磁盘中找到你安装的软件，并把运行所需要的数据复制到内存中，由CPU直接和内存进行交互，读取内存中的数据处理，并返回对应的结果保存到内存中。</p><blockquote><p>Tips：软件不是在磁盘中运行的，而是在内存中运行的，因为内存的读写速度比磁盘快，<strong>为了缓和磁盘之间的速度不匹配问题，程序执行前必须将硬盘上的数据复制到内存，CPU 才能够着手处理</strong>，这个过程就是<strong>载入内存</strong>（Load into Memory）</p></blockquote><p>比如说，我们打开了某个 Word 文档，并输入了一些文字，虽然我们直观看到的已经发生变化了，但是磁盘中存储的文档仍然没有改变，它仍然是之前的数据，新增的文字只是暂时保存到了内存，只有我们手动保存了这篇文档比如 Ctrl + s 才会将修改保存到磁盘中。</p><p>而由于内存是易失性的，也就是说断电后数据就丢失了，所以如果你编辑完 Word 文档忘记保存或者断电导致关机了，那么你将永远无法找回这些内容。</p><p><img src="https://gitee.com/veal98/images/raw/master/img/20210415130522.png"></p><p><strong>寄存器（Register）和高速缓存都直接内嵌在 CPU 中</strong>：</p><p>常说 32 位或者 64 位的 CPU，其实指的就是寄存器的位数,寄存器功能涵括数学运算，控制程序执行流程、标记CPU运行状态等</p><ul><li>EAX 寄存器通常被用在加法运算中，用来保存某个加数或运算结果；</li><li>EIP 寄存器中存储的值是下一条指令的地址，CPU 执行完当前指令后，就会根据 EIP 的值去寻找下一条指令，也就是说如果我们改变 EIP 寄存器的值，也就会相应的改变程序的执行流程。</li></ul><p><strong>高速缓存的作用：</strong></p><p>如果 CPU 每次都从内存中读取数据，会严重拖慢其运行速度，CPU 不得不浪费大量的时间来等待内存中数据操作的结束。为此，我们在 CPU 内部设置一个缓存，将使用频繁的数据暂时从内存中读取到缓存里来，这样，如果<strong>缓存命中</strong>，就直接从缓存中读取即可，不必访问内存了。</p><p><strong>虚拟内存</strong>：</p><p>程序内存的占用不等于实际内存的大小，当程序运行所需存储空间大于内存容量时，会把内存中暂时不用的数据写回磁盘，当需要的时候重新读取，内存中存放的数据就是热点数据。这样磁盘有一部分空间存放内存暂时不用的数据，这个数据就是虚拟内存。</p><p>比如说：有时候电脑只有4g内存但是能运行需要5g内存的应用程序，这是怎么回事呢？答案是：有1g的虚例内存。对于用户来说似乎有了个比实际内存大的多的内存，但实际的物理内存大小并没有发生改变，只是在逻辑上进行了扩充。</p><p><strong>可以这么理解，引入虚拟内存的概念后，在内存和磁盘之间，内存就充当了缓存的作用</strong>。CPU 优先从内存中获取数据，如果命中，就不需要去访问磁盘。这里和我们上文所说的 CPU 中的缓存和内存之间的关系是不是一模一样？</p><p>本文参考来源：</p><ul><li><a href="https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6-%E4%BA%94%E5%88%86%E9%92%9F%E6%89%AB%E7%9B%B2-%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84?id=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%ae%be%e8%ae%a1%e4%ba%86%e5%88%86%e5%b1%82%e5%ad%98%e5%82%a8%e4%bd%93%e7%b3%bb">https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6-%E4%BA%94%E5%88%86%E9%92%9F%E6%89%AB%E7%9B%B2-%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84?id=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%ae%be%e8%ae%a1%e4%ba%86%e5%88%86%e5%b1%82%e5%ad%98%e5%82%a8%e4%bd%93%e7%b3%bb</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统02</title>
      <link href="/2021/12/10/ji-suan-ji-ji-chu/cao-zuo-xi-tong-02/"/>
      <url>/2021/12/10/ji-suan-ji-ji-chu/cao-zuo-xi-tong-02/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统02"><a href="#操作系统02" class="headerlink" title="操作系统02"></a>操作系统02</h1><h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p>进程就是程序的一次执行过程，它是动态的产生，变化，消亡的有生命周期的；并且进程还包括运行中占用的系统空间、CPU等；</p><p>为了防止一个进程中两个线程同时使用一个内存区域的简单办法就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>某些内存区域，只能供给固定数目的线程使用时，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做 “信号量”（Semaphore），用来保证多个线程不会互相冲突。</p><h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><ul><li><p>PCB ：是提供给操作系统用的，是进程存在的标志，一般包含4个内容：</p><p>1）<strong>进程描述信息</strong>：用来让操作系统区分各个进程</p><ul><li>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的 “身份证号”— <strong>PID</strong>（ProcessID，进程 ID）</li><li>另外，进程描述信息还包含进程所属的用户 ID（<strong>UID</strong>）</li></ul><p>2）<strong>进程控制和管理信息</strong>：记录进程的运行情况。比如 CPU 的使用时间、磁盘使用情况、网络流量使用情况等。</p><p>3）<strong>资源分配清单</strong>：记录给进程分配了哪些资源。比如分配了多少内存、正在使用哪些 I/O 设备、正在使用哪些文件等。</p><p>4）<strong>CPU 相关信息</strong>：进程在让出 CPU 时，必须保存该进程在 CPU 中的各种信息，比如各种寄存器的值。用于实现进程切换，确保这个进程再次运行的时候恢复 CPU 现场，从断点处继续执行。这就是所谓的<strong>保存现场信息</strong>。</p></li><li><p>程序段：程序的代码生成的指令序列</p></li><li><p>数据段：进程运行中的各种数据（比如定义的变量）</p></li></ul><p>程序段、数据段是给进程自己用的，PCB给操作系统用的。</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>经典的进程三态模型如下：</p><ul><li><strong>运行态</strong>（running）：进程占有 CPU 正在运行。</li><li><strong>就绪态</strong>（ready）：进程具备运行条件，等待系统分配 CPU 以便运行。</li><li><strong>阻塞态</strong> / 等待态（wait）：进程不具备运行条件，正在等待某个事件的完成。</li></ul><p><img src="https://gitee.com/veal98/images/raw/master/img/20210219154606.png" alt="img"></p><p>上图中的时间片用完，可以这样理解：</p><p>进程是并发执行的嘛，宏观上在一段时间内能同时运行多个程序，但其实微观上是交替发生的。也就是说 CPU 一般不会让一个进程一次性执行完，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。某个进程的时间片用完后这个进程就会进入就绪态，而其他被分配到时间片的进程就会进入运行态。这个处于就绪态的进程就需要等待进程调度程序的下一次调度，为其分配 CPU 时间片后才能再次恢复运行。</p><p>需要注意的是：<strong>阻塞态是由于缺少需要的资源从而由运行态转换而来，但是该资源不包括 CPU 时间片，缺少 CPU 时间片会从运行态转换为就绪态</strong>。</p><p>很多系统中都增加了新建态（new）和终止态（exit），形成<strong>五态模型</strong>：</p><ul><li><strong>新建态</strong>（new）：进程正在被创建时的状态</li><li><strong>终止态</strong>（exit）：进程正在从系统中消失时的状态</li></ul><p><img src="https://gitee.com/veal98/images/raw/master/img/20210219155101.png" alt="img"></p><p>从上图可以发现，<strong>只有就绪态和运行态可以相互转换，其它的都是单向转换</strong>。</p><p>这些不同状态的进程操作系统是如何进行管理的呢？上文说过，PCB 是提供给操作系统使用的，是操作系统管理进程的主要依据。没错，操作就是通过 PCB 来管理这些拥有不同状态的进程的。</p><p>进程的 PCB 会通过某种方式组织起来，一般来说，操作系统会把处于同一状态的所有进程的 PCB 链接在一起，这种数据结构就称为<strong>进程队列</strong>（Process Queue）。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>原语是操作系统内核中一段特殊的程序，它具有原子性（该程序运行必须一次运行，不可中断）</p><p>操作系统通过原语实现进程状态的转化，也就是进程的创建、终止、阻塞、唤醒；</p><p>进程的创建过程：</p><ul><li>在进程列表中增加一项，从 PCB 池中申请一个空闲的 PCB（PCB 是有限的，若申请失败则创建失败），为新进程分配一个唯一的进程标识符；</li><li>为新进程分配地址空间，由进程管理程序确定加载至进程地址空间中的程序；</li><li>为新进程分配各种资源；</li><li>初始化 PCB，如进程标识符、CPU 初始状态等；</li><li>把新进程的状态设置为就绪态，并将其移入就绪队列，等待被调度运行。</li></ul><h2 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h2><p>各个进程之间共享内存资源，当进程切换时不同进程分配不同的内存空间这就是进程的上下文切换。也就是一个进程切换到另一个进程，</p><p>进程的切换一定发生在内核态中</p><p>进程切换也就是切换原语的流程：</p><ul><li>首先，将进程 A 的运行环境信息存入 PCB，这个运行环境信息就是进程的上下文（Context）</li><li>然后，将 PCB 移入相应的进程队列；</li><li>选择另一个进程 B 进行执行，并更新其 PCB 中的状态为运行态</li><li>当进程 A 被恢复运行的时候，根据它的 PCB 恢复进程 A 所需的运行环境</li></ul><h2 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h2><p>线程的特征和进程差不多，进程有的他基本都有，比如：</p><ul><li>线程具有就绪、阻塞、运行三种基本状态，同样具有状态之间的转换关系；</li><li>线程间可以并发执行</li><li>在多 CPU 环境下，各个线程也可以分派到不同的 CPU 上并行执行</li></ul><p>线程的优点：</p><ul><li><p>一个进程中可以同时存在多个线程，这些线程共享该进程的资源。进程间的通信必须请求操作系统服务（因为 CPU 要切换到内核态），开销很大。而同进程下的线程间通信，无需操作系统干预，开销更小。</p><p>不过，需要注意的是：从属于不同进程的线程间通信，也必须请求操作系统服务。</p></li><li><p>线程间的并发比进程的开销更小，系统并发性提升。</p><p>同样，需要注意的是：从属于不同进程的线程间切换，它是会导致进程切换的，所以开销也大。</p></li></ul><p>线程的缺点：</p><ul><li>当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。</li></ul><p>举个例子，对于游戏的用户设计，就不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程</p><h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>进程调度，就是<strong>从进程的就绪队列（阻塞）中按照一定的算法选择一个进程并将 CPU 分配给它运行</strong>，以实现进程的并发执行。</p><h2 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h2><p>非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件发生而被阻塞时，才会把 CPU 让给其他进程。</p><ul><li>先到先服务FCFS</li></ul><p>先到的进程就先被调度</p><ul><li>最短作业优先SJF</li></ul><p>当前已到达的进程中运行时间最短的先调用</p><ul><li>高响应比优先HRRN</li></ul><p>只有当前运行的进程主动放弃 CPU 时（正常/异常完成，或主动阻塞），才需要进行调度，<strong>调度时计算所有就绪进程的响应比，为响应比最高的进程分配 CPU</strong>。</p><p>响应比 = (进程的等待时间 + 进程需要的运行时间) / 进程需要的运行时间</p><h2 id="抢占式调度算法"><a href="#抢占式调度算法" class="headerlink" title="抢占式调度算法"></a>抢占式调度算法</h2><p>抢占式的意思就是，当进程正在运行的时，可以被打断，把 CPU 让给其他进程。</p><ul><li>最短剩余时间优先</li></ul><p><strong>当一个新的进程到达时，把它所需要的整个运行时间与当前进程的剩余运行时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。</strong></p><ul><li>轮转调度算法</li></ul><p><strong>就绪队列中的每个进程轮流地运行一个时间片，当时间片耗尽时就强迫当前运行进程让出 CPU 资源，转而排到就绪队列尾部，等待下一轮调度</strong>。所以，一个进程一般都需要多次轮转才能完成。</p><p>轮转调度算法对每个进程都一视同仁，就好比大家都排好队，一个一个来，每个人都运行一会儿再接着重新排队等待运行。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p><strong>一个进程中可以有多个线程，它们共享这个进程的资源。</strong></p><p><strong>线程又称为迷你进程，但是它比进程更容易创建，也更容易撤销</strong>。</p><p>引入线程前，进程是资源分配和独立调度的基本单位。引入线程后，<strong>进程是资源分配的基本单位，线程是独立调度的基本单位</strong>。</p><p>进程调度，就是<strong>从进程的就绪队列（阻塞）中按照一定的算法选择一个进程并将 CPU 分配给它运行</strong>，以实现进程的并发执行</p></blockquote><p>本文来源于：</p><ul><li><a href="https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统01</title>
      <link href="/2021/12/09/ji-suan-ji-ji-chu/cao-zuo-xi-tong-01/"/>
      <url>/2021/12/09/ji-suan-ji-ji-chu/cao-zuo-xi-tong-01/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统01"><a href="#操作系统01" class="headerlink" title="操作系统01"></a>操作系统01</h1><blockquote><p>不懂计算机系统也能写程序，这是不争的事实。但是我们<strong>学习操作系统并非是为了去创造一个操作系统，而是为了理解操作系统之后写出更好的程序</strong>。</p></blockquote><h1 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h1><p>操作系统本质上是运行在计算机上的程序，它是硬件和软件沟通的桥梁，其主要功能有：</p><ul><li><strong>对计算机硬件资源进行管理、分配和调度</strong></li><li><strong>为用户提供一个友好、清晰且简单的操作界面</strong>（专业的叫法是 <strong>壳 Shell</strong>）</li></ul><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>处理器就是CPU，<strong>一个程序需要放入内存并给它分配 CPU 才能执行</strong>。</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><h1 id="操作系统的4个特征"><a href="#操作系统的4个特征" class="headerlink" title="操作系统的4个特征"></a>操作系统的4个特征</h1><p>并发、共享、虚例、异步</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>其中并发、共享是操作系统最基本的特征，没有这两个就谈不上、虚例和共享</p><ul><li><p><strong>并发</strong>：并发是指宏观上在<strong>一段时间内</strong>能同时运行多个程序。当然，这些程序宏观上是同时发生的，但微观上是交替发生的。操作系统通过引入进程和线程，使得程序能够并发运行。</p></li><li><p><strong>并行</strong>：并行则指<strong>同一时刻</strong>能运行多个指令，指两个或多个事件在<strong>同一时刻同时发生</strong>。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p></li></ul><p>并发、并行和CPU之间的关系</p><ul><li><strong>单核 CPU</strong>同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>地执行 ；</li><li><strong>多核 CPU</strong>同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>地执行。</li></ul><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>共享即<strong>资源共享</strong>，是指系统中的资源可供内存中多个<strong>并发</strong>执行的进程共同使用。</p><p>主要有两种共享方式：</p><p>1）<strong>互斥共享</strong></p><p>所谓互斥共享，就是说虽然这个资源是共享的，所有进程都能够使用，但是<strong>同一个资源在某一时刻只允许一个进程访问</strong>，也称为互斥访问。</p><p>举个互斥共享的例子：</p><p>如果我们同时使用 QQ 和微信视频，同一时间段内摄像头资源只能分配给其中的一个进程。</p><p>2）<strong>同时共享</strong></p><p>同时共享与互斥共享相反，<strong>允许一个时间段内多个进程 “同时” 对系统中的某些资源进行访问</strong>。当然，所谓的 “同时” 往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问（即分时共享）</p><p>比如，qq发送文件a，微信发送文件b，都是同时同时访问硬盘的；</p><h2 id="虚拟："><a href="#虚拟：" class="headerlink" title="虚拟："></a>虚拟：</h2><p><strong>空分复用技术</strong>和<strong>时分复用技术</strong></p><p>多个进程能在同一个 CPU 上并发执行就是因为使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>一些程序运行的内存大于电脑内存还能够运行就是因为使用了空分复用技术，把内存作为高速缓存使用，只保存需要频繁使用的，其他大部分放在磁盘上。</p><p>显然，如果失去了并发性，一个时间段内系统中只能运行一道程序，那也就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong></p><h2 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h2><p>异步是指：在多道程序环境下，允许多个程序并发执行，但<strong>由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进</strong>，这就是进程的异步性。</p><h1 id="操作系统的4个核心"><a href="#操作系统的4个核心" class="headerlink" title="操作系统的4个核心"></a>操作系统的4个核心</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程就是正在运行的程序，不仅包括运行中的程序实体，还包括它所占用的系统资源，比如CPU、内存、网络等；</p><p>一个进程中可以有多个线程，它们共享进程资源；</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理做的事情大概就是：</p><ul><li>把使用频繁的部分程序放入内存</li><li>当内存满的时候，替换掉内存中的某些部分</li></ul><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p>每个文件可以看做一个地址空间，每个文件都是独立于其他文件的，有关文件的构造、命名、存取等都是其设置的内容</p><h2 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h2><p>操作系统必须高效的管理输入输出设备</p><h3 id="什么是内核态和用户态"><a href="#什么是内核态和用户态" class="headerlink" title=" 什么是内核态和用户态"></a><a href="https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1-%E4%BA%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E4%BB%8E%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%BC%80%E5%A7%8B?id=%E2%91%A0-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"> <strong>什么是内核态和用户态</strong></a></h3><p><strong>系统调用的过程</strong>简略版大致如下：</p><p>1）在用户态，应用程序传递系统调用参数</p><p>2）执行陷入指令，引发一个内中断，使 CPU 进入内核态</p><p>3）在内核态，执行相应的请求，内核程序处理系统调用</p><p>4）返回应用程序</p><p>本文参考来源;</p><ul><li><a href="https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/12/09/shu-ju-jie-gou-yu-suan-fa/dong-tai-gui-hua/"/>
      <url>/2021/12/09/shu-ju-jie-gou-yu-suan-fa/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote><p>一个<strong>规模</strong>比较大的问题分成几个<strong>规模</strong>比较小的问题，然后由小的问题推导出大的问题</p><p>动态规划可以分为如下四大类，可以依次进行学习：线性动规，区域动规，树形动规，背包动规。</p></blockquote><h1 id="一个案列引入动态规划"><a href="#一个案列引入动态规划" class="headerlink" title="一个案列引入动态规划"></a>一个案列引入动态规划</h1><h2 id="数字三角形–递归"><a href="#数字三角形–递归" class="headerlink" title="数字三角形–递归"></a>数字三角形–递归</h2><p><img src="/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20220327221725745.png" alt="image-20220327221725745"></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或右下走。只需要求出这个最大和即可，不必给出具体路径。三角形的行数大于1小于等于100，数字为 0 - 99</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>虽然只是一道简单的递推题，即使用循环都能做出来，但是从零开始逐渐分析，慢慢的就能体会到动态规划的用处，也让我对动态规划的理解也更加的深入。让我们一步一步的剖析这个从无到最终演变的过程。</p><p>输入：</p><pre class="line-numbers language-none"><code class="language-none">5 73 88 1 02 7 4 44 5 2 6 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>题解： 首先用最简单的二维数组存数字三角形，用递归的方式求一下结果试一下；</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//d(r,j)表示第r行第j列数字//maxSum(r,j)表示从d (r,j)到底边的最佳路径的数字之和 int n;//数字三角形行数 int D[101][101];//存放数字三角形 int maxSum(int i,int j){if(i == n) return D[i][j];//递归出口int x = maxSum(i+1,j);// d(i,j)到下面一行的最优选择 int y = maxSum(i+1,j+1);return max(x,y)+D[i][j]; }int main(){cin&gt;&gt;n;for(int i=1;i&lt;=n;++i)for(int j=1;j&lt;=n;++j)cin&gt;&gt;D[i][j];cout&lt;&lt;maxSum(1,1)&lt;&lt;endl;//求第1行第1列到底边的最优路径 return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数字三角形–改进"><a href="#数字三角形–改进" class="headerlink" title="数字三角形–改进"></a>数字三角形–改进</h2><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>如果采用递规的方法，深度遍历每条路径，存在大量重复计算。则时间复杂度为 2^n ,对于 n = 100 行， 肯定超时。如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。那么可以用O(n^2 )时间完成计算。因为三角形的数字总数是 n(n+1)/2</p><h3 id="改进题解："><a href="#改进题解：" class="headerlink" title="改进题解："></a>改进题解：</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 101int D[MAX][MAX]; int n;int maxSum[MAX][MAX];int MaxSum(int i, int j){if( maxSum[i][j] != -1 )return maxSum[i][j];if(i==n)maxSum[i][j] = D[i][j];else {int x = MaxSum(i+1,j);int y = MaxSum(i+1,j+1);maxSum[i][j] = max(x,y)+D[i][j];}return maxSum[i][j];}int main(){int i,j;cin &gt;&gt; n;for(i=1;i&lt;=n;i++)        for(j=1;j&lt;=i;j++) {            cin &gt;&gt; D[i][j];            maxSum[i][j] = -1;        }cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数字三角形–记忆形递推"><a href="#数字三角形–记忆形递推" class="headerlink" title="数字三角形–记忆形递推"></a>数字三角形–记忆形递推</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>接下来是比较容易理解，也是最容易见到的递推，但是，和一般的递推有一点点不一样的是，没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推，那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。</p><blockquote><p>ps：因为用一维数组maxSum[100]来记忆过程中的一行的MaxSum，也就是记忆形递推吧；</p></blockquote><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 101int D[MAX][MAX]; int n;int maxSum[MAX][MAX];int main() {int i,j;cin &gt;&gt; n;for(i=1;i&lt;=n;i++)for(j=1;j&lt;=i;j++)cin &gt;&gt; D[i][j];for( int i = 1;i &lt;= n; ++ i )maxSum[n][i] = D[n][i];for( int i = n-1; i&gt;= 1; --i )for( int j = 1; j &lt;= i; ++j )maxSum[i][j] =max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j]cout &lt;&lt; maxSum[1][1] &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数字三角形–空间优化"><a href="#数字三角形–空间优化" class="headerlink" title="数字三角形–空间优化"></a>数字三角形–空间优化</h2><p>进一步考虑，连maxSum数组都可以不要，直接用D的第n行替代maxSum即可。 节省空间，时间复杂度不变</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 101int D[MAX][MAX];int n; int * maxSum;int main(){int i,j;cin &gt;&gt; n;for(i=1;i&lt;=n;i++)for(j=1;j&lt;=i;j++)cin &gt;&gt; D[i][j];maxSum = D[n]; //maxSum指向第n行    for( int i = n-1; i&gt;= 1; --i )    for( int j = 1; j &lt;= i; ++j )    maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j];    cout &lt;&lt; maxSum[1] &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由一个数字三角形的案例我们简单的了解了什么是</p><h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p>问题描述 一个数的序列ai，当a1 &lt; a2 &lt; … &lt; aS的时候，我们称这个序 列是上升的。对于给定的一个序列(a1 , a2 , …, aN)，我们可以得到 一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK  &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子 序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比 如子序列(1, 3, 5, 8).  你的任务，就是对于给定的序列，求出最长上升子序列的长度。</p><p>输入数据 </p><p>​        输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给 出序列中的N个整数，这些整数的取值范围都在0到10000。 </p><p>输出要求 </p><p>​        最长上升子序列的长度。 </p><p>输入样例 </p><pre class="line-numbers language-none"><code class="language-none">7 1 7 3 5 9 4 8 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出样例 </p><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、把原问题分解成子问题</p><p>求以ak（k=1, 2, 3…N）为终点的最长上升子序列的长度，只要这N个子问题都解决了，那么这N个子问题的解中， 最大的那个就是整个问题的解。</p><p>2、确定状态</p><p>子问题只和一个变量– 数字的位置相关。因此序列中数的 位置k 就是“状态”，而状态 k 对应的“值”，就是以ak做为 “终点”的最长上升子序列的长度。 状态一共有N个。</p><p>3、找状态转移方程</p><p>maxLen (k)表示以ak做为“终点”的 最长上升子序列的长度那么： 初始状态：maxLen (1) = 1  maxLen (k) = max { maxLen (i)：1&lt;=i &lt; k 且 ai &lt; ak且 k≠1 } + 1 若找不到这样的i,则maxLen(k) = 1</p><p>题解：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">```# 最长公共子序列输入两行字符串，求两字符串最长公共子序列```C++#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1010;char size1[MAXN];char size2[MAXN];int maxLen[MAXN][MAXN];int main(){int i,j;/*for(i=0;i&lt;MAXN;++i){size1[i] = getchar();if(size1[i] == '\n') break;}   size1[i]='\0';//最后一个字符赋值作为为c语言判断 字符串结束的依据 */cin&gt;&gt;size1;cin&gt;&gt;size2;int length1 = strlen(size1);int length2 = strlen(size2);for( i = 0;i &lt;= length1; i ++ )//第1列初始化为0 maxLen[i][0] = 0;for( j = 0;j &lt;= length2; j ++ )//第1行初始化为0 maxLen[0][j] = 0;//核心解题关键 for( i = 1;i &lt;= length1;i++ ) {for( j = 1;j &lt;= length2;j++ ) {if( size1[i-1] == size2[j-1] )maxLen[i][j] = maxLen[i-1][j-1] + 1;elsemaxLen[i][j] = max(maxLen[i][j-1],maxLen[i-1][j]);}}cout &lt;&lt; maxLen[length1][length2];return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解题思路总结："><a href="#解题思路总结：" class="headerlink" title="解题思路总结："></a>解题思路总结：</h1><p><strong>先确定问题是否能用动态规划解决，能用动规解决的问题的特点如下：</strong> </p><ol><li><strong>问题具有最优子结构性质</strong>。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。 </li><li><strong>无后效性</strong>。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪 种手段或经过哪条路径演变到当前的这若干个状态，没有关系。</li></ol><p><strong>一般情况下，问题大致了解不一定能看出是否可以用动态规划解题，解题步骤大致如下：</strong></p><p>1、把原问题分解成子问题</p><blockquote><p>子问题和原问题相同或类似，子问题的解一旦求出就会被保存，所以只会求一次</p></blockquote><p>2、确定状态</p><p>3、找状态转移方程</p><hr><h1 id="以下为刷题：洛谷-P1216"><a href="#以下为刷题：洛谷-P1216" class="headerlink" title="以下为刷题：洛谷:P1216 "></a>以下为刷题：<a href="https://www.luogu.com.cn/problem/P1216">洛谷:P1216 </a></h1><p>Step1：<strong>定义数组元素的含义</strong></p><p>定义 dp[i] [j]的含义为：当走到塔尖时路经数字最大和</p><p>Step2：<strong>找出关系数组元素间的关系式</strong>（状态转移方程）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Step3：<strong>找出初始值</strong></p><p>初始值dp[i]（最后一行）根据输入值变化而变化</p><p>题解代码如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;bits/stdc++.h&gt;using namespace std;int dp(int m){vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(m));for (int i = 0; i &lt; m; ++i) {for (int j = 0; j &lt;= i; ++j) {    cin&gt;&gt;dp[i][j];}}for (int i = m-2; i &gt;= 0; --i) {    for (int j = 0; j &lt;= i; ++j) {        dp[i][j] += max(dp[i+1][j],dp[i+1][j+1]);    }}return dp[0][0];}int main(void){int r,sum;cin&gt;&gt;r;sum=dp(r);cout&lt;&lt;sum;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一维DP：青蛙跳台阶"><a href="#一维DP：青蛙跳台阶" class="headerlink" title="一维DP：青蛙跳台阶"></a>一维DP：青蛙跳台阶</h1><p>问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="步骤一、定义数组元素的含义"><a href="#步骤一、定义数组元素的含义" class="headerlink" title="步骤一、定义数组元素的含义"></a>步骤一、定义数组元素的含义</h3><p>定义 dp[i] 的含义为：<strong>跳上一个 i 级的台阶总共有 dp[i] 种跳法</strong></p><h3 id="步骤二、找出数组元素间的关系式"><a href="#步骤二、找出数组元素间的关系式" class="headerlink" title="步骤二、找出数组元素间的关系式"></a>步骤二、找出数组元素间的关系式</h3><p> dp[n] = dp[n-1] + dp[n-2]</p><h3 id="步骤三、找出初始条件"><a href="#步骤三、找出初始条件" class="headerlink" title="步骤三、找出初始条件"></a>步骤三、找出初始条件</h3><p>dp[0] = 0、dp[1] = 1、dp[2] = 2</p><p>即 n &lt;= 2 时，dp[n] = n.</p><h3 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h3><pre class="line-numbers language-JAva" data-language="JAva"><code class="language-JAva">//简单代码写出题解，当然它还可以优化；int f( int n ){    if(n &lt;= 2)    return n;    // 先创建一个数组来保存历史数据    int[] dp = new int[n+1];    // 给出初始值    dp[0] = 0;    dp[1] = 1;    dp[2] = 1;    // 通过关系式来计算出 dp[n]    for(int i = 2; i &lt;= n; i++){        dp[i] = dp[i-1] + dp[i-2];    }    // 把最终结果返回    return dp[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二维数组DP：最多路径数"><a href="#二维数组DP：最多路径数" class="headerlink" title="二维数组DP：最多路径数"></a>二维数组DP：最多路径数</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个机器人位于一个 m x n 网格的左上角</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角</p><p>问总共有多少条不同的路径？</p><h3 id="步骤一、定义数组元素的含义-1"><a href="#步骤一、定义数组元素的含义-1" class="headerlink" title="步骤一、定义数组元素的含义"></a>步骤一、定义数组元素的含义</h3><p>由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp[i] [j]的含义为：<strong>当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径</strong>。     </p><p>注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是答案。</p><h3 id="步骤二：找出关系数组元素间的关系式"><a href="#步骤二：找出关系数组元素间的关系式" class="headerlink" title="步骤二：找出关系数组元素间的关系式"></a>步骤二：找出关系数组元素间的关系式</h3><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><p>一种是从 (i-1, j) 这个位置走一步到达</p><p>一种是从(i, j - 1) 这个位置走一步到达</p><p>因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 </p><p><strong>dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]</strong></p><h3 id="步骤三、找出初始值"><a href="#步骤三、找出初始值" class="headerlink" title="步骤三、找出初始值"></a>步骤三、找出初始值</h3><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><p>dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往右走</p><p>dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走</p><h3 id="题解代码："><a href="#题解代码：" class="headerlink" title="题解代码："></a>题解代码：</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//简单代码写出题解，当然它还可以优化；public static int uniquePaths(int m, int n) {    if (m &lt;= 0 || n &lt;= 0) {        return 0;    }    int[][] dp = new int[m][n];    // 初始化    for(int i = 0; i &lt; m; i++){      dp[i][0] = 1;    }    for(int i = 0; i &lt; n; i++){      dp[0][i] = 1;    }        // 推导出 dp[m-1][n-1]    for (int i = 1; i &lt; m; i++) {        for (int j = 1; j &lt; n; j++) {            dp[i][j] = dp[i-1][j] + dp[i][j-1];        }    }    return dp[m-1][n-1];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++版的，虽然语言不同，但思维差不多的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int uniquePaths(int m, int n) {    //创建m×n的二维数组，而且可以通过v[i][j]的方式来访问元素（vector支持下标访问元素）    //定义了一个vector容器，元素类型为vector&lt;int&gt;，初始化为包含m个vector&lt;int&gt;对象，每个对象都是一个新创立的vector&lt;int&gt;对象的拷贝，而这个新创立的vector&lt;int&gt;对象被初始化为包含n个0。    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));    // 初始化    for (int i = 0; i &lt; m; ++i) {        dp[i][0] = 1;    }    for (int j = 0; j &lt; n; ++j) {        dp[0][j] = 1;    }    // 推导出dp[m-1][n-1]    for (int i = 1; i &lt; m; ++i) {        for (int j = 1; j &lt; n; ++j) {            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        }    }    return dp[m - 1][n - 1];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码优化："><a href="#代码优化：" class="headerlink" title="代码优化："></a>代码优化：</h3><p> 前面的基础解法中空间复杂度为O(n * m)，下面我们来讲解如何优化成 O(n)。</p><p>根据公式 </p><pre class="line-numbers language-none"><code class="language-none">dp[i][j]= dp[i-1][j] + dp[i][j-1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>，我们可以知道，当我们要计算第 i 行的值时，<strong>除了会用到第 i - 1 行外，其他第 1 至 第 i-2 行的值我们都是不需要用到的</strong>，只需要用一个一维的 dp[] 来保存<strong>一行</strong>的历史记录就可以了。然后在计算机的过程中，不断着更新 dp[] 的值。</p><p>以往的二维的时候， dp[i][j] = dp[i-1] [j]+ dp[i][j-1]。现在转化成一维，不就是 <strong>dp[i] = dp[i] + dp[i-1]</strong> 吗？</p><p>即 dp[1] = dp[1] + dp[0]，而且还动态帮我们更新了 dp[1] 的值。因为刚开始 dp[i] 的保存第一行的值的，现在更新为保存第二行的值。</p><p>dp[i] = dp[i-1] + dp[i]</p><blockquote><pre class="line-numbers language-none"><code class="language-none">dp[i-1] 相当于之前的 dp[i-1][j]，dp[i] 相当于之前的 dp[i][j-1]。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//优化代码如下，时间复杂度O（m*n），空间复杂度O（n）public static int uniquePaths(int m, int n) {    if (m &lt;= 0 || n &lt;= 0) {        return 0;    }    int[] dp = new int[n];     // 初始化    for(int i = 0; i &lt; n; i++){      dp[i] = 1;    }        // 公式：dp[i] = dp[i-1] + dp[i]    for (int i = 1; i &lt; m; i++) {        // 第 i 行第 0 列的初始值        dp[0] = 1;        for (int j = 1; j &lt; n; j++) {            dp[j] = dp[j-1] + dp[j];        }    }    return dp[n-1];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后要求的答案就是：dp[n-1]</p><h1 id="二维数组DP：最小路径和"><a href="#二维数组DP：最小路径和" class="headerlink" title="二维数组DP：最小路径和"></a>二维数组DP：最小路径和</h1><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><h3 id="步骤一、定义数组元素的含义-2"><a href="#步骤一、定义数组元素的含义-2" class="headerlink" title="步骤一、定义数组元素的含义"></a>步骤一、定义数组元素的含义</h3><p>由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：**当机器人从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i] [j]**。那么，dp[m-1] [n-1] 就是我们要的答案了。</p><p>不过这次不是计算所有可能路径，而是<strong>计算哪一个路径和是最小的</strong>，那么我们要从这两种方式中，选择一种，使得dp[i] [j] 的值是最小的，显然有</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>，dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// arr[i][j] 表示网格总的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="步骤三、找出初始值-1"><a href="#步骤三、找出初始值-1" class="headerlink" title="步骤三、找出初始值"></a>步骤三、找出初始值</h3><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><p>dp[0] [j] = arr[0] [j] + dp[0] [j-1]; // 相当于最上面一行，机器人只能一直往左走</p><p>dp[i] [0] = arr[i] [0] + dp[i] [0]; // 相当于最左面一列，机器人只能一直往下走</p><h3 id="题解代码：-1"><a href="#题解代码：-1" class="headerlink" title="题解代码："></a>题解代码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化最左边的列</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 初始化最上边的行</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">// 推导出 dp[m-1][n-1]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲</p></blockquote><h1 id="hard-题目"><a href="#hard-题目" class="headerlink" title="hard 题目"></a>hard 题目</h1><p><strong>问题描述</strong>：</p><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符 删除一个字符 替换一个字符</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">示例：输入<span class="token operator">:</span> word1 <span class="token operator">=</span> <span class="token string">"horse"</span><span class="token punctuation">,</span> word2 <span class="token operator">=</span> <span class="token string">"ros"</span>输出<span class="token operator">:</span> <span class="token number">3</span>解释<span class="token operator">:</span> horse <span class="token operator">-&gt;</span> rorse <span class="token punctuation">(</span>将 <span class="token string">'h'</span> 替换为 <span class="token string">'r'</span><span class="token punctuation">)</span>rorse <span class="token operator">-&gt;</span> rose <span class="token punctuation">(</span>删除 <span class="token string">'r'</span><span class="token punctuation">)</span>rose <span class="token operator">-&gt;</span> ros <span class="token punctuation">(</span>删除 <span class="token string">'e'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本文参考来源：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划，连刷 40 道题，我总结了这些套路，看不懂你打我（万字长文） - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/whl583593404/article/details/49804217">C++中的vector</a></p></li><li><p><a href="https://leetcode-cn.com/problems/unique-paths/">Loading Question… - 力扣（LeetCode） (leetcode-cn.com)</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和 - 力扣（LeetCode） (leetcode-cn.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何求解金矿问题</title>
      <link href="/2021/12/08/shu-ju-jie-gou-yu-suan-fa/ru-he-qiu-jie-jin-kuang-wen-ti/"/>
      <url>/2021/12/08/shu-ju-jie-gou-yu-suan-fa/ru-he-qiu-jie-jin-kuang-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="金矿问题题目"><a href="#金矿问题题目" class="headerlink" title="金矿问题题目"></a>金矿问题题目</h2><p>很久很久以前，有一位国王拥有5座金矿，每座金矿的黄金储量不同， 需要参与挖掘的工人人数也不同。例如有的金矿储量是500kg黄金，需要5个工人来挖掘；有的金矿储量是200kg黄金，需要3个工人来挖掘…… 如果参与挖矿的工人的总数是10。每座金矿要么全挖，要么不挖，不能 派出一半人挖取一半的金矿。要求用程序求出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先分析题意得出这是一个动态规划问题，所谓动态规划就是把复杂的问题简化成规模较小的子问题，再从简单的子问题自底向上一步一步递推，最终得到复杂问题的最优解。</p><p>动态规划的要点：</p><p>确定全局最优解和最优子结构之间的关系，以及问题的边界。这个关系用数学公式来表达的话，就叫作状态转移方程式 。</p><p>先找问题得边界：</p><p>一直把问题简化成在0个金矿或0个 工人时的最优选择，这个收益结果显然是0，也就是问题的边界 。</p><p>自底向上求解：</p><ul><li><a href="https://www.zhihu.com/search?q=%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:154023067%7D">状态转移方程</a>: n是当前金矿储量，w是当前金矿所需人数 ,p是挖掘金矿所需人数数组，g是金矿储量数组</li><li>F(n,w) = F(n-1,w) (n&gt;1,w&lt;p[n-1])</li><li>F(n,w) = max( F(n-1,w),F(n-1,w-p[n-1])+g[n-1]) (n&gt;1,w&gt;=p[n-1])</li><li>二维数组表示这张对应得表</li></ul><h2 id="递归求解代码"><a href="#递归求解代码" class="headerlink" title="递归求解代码"></a>递归求解代码</h2><pre class="line-numbers language-none"><code class="language-none">/** 获得金矿最优收益* @param w 工人数量* @param n 可选金矿数量* @param p 金矿开采所需的工人数量* @param g 金矿储量  */  public static int getBestGoldMining(int w, int n,int[] p, int[] g){  if(w==0 || n==0){   return 0;   }   if(w&lt;p[n-1]){   return getBestGoldMining(w, n-1, p, g);   }   return Math.max(getBestGoldMining(w, n-1, p, g),getBestGoldMining(w-p[n-1], n*1, p, g)+g[n-1]);   } public static void main(String[] args) { int w = 10; int[] p = {5, 5, 3, 4 ,3}; int[] g = {400, 500, 200, 300 ,350}; System.out.println(" 最优收益：" + getBestGoldMining(w,g.length, p, g));}//单纯用递归去计算得话时间复杂度就是O(2^n)，在这个算法中有很多重复得调用计算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态规划代码"><a href="#动态规划代码" class="headerlink" title="动态规划代码"></a>动态规划代码</h2><pre class="line-numbers language-none"><code class="language-none">/** * 获得金矿最优收益 * @param w 工人数量 * @param p 金矿开采所需的工人数量 * @param g 金矿储量*/ public static int getBestGoldMiningV2(int w, int[] p, int[] g){//创建表格int[][] resultTable = new int[g.length+1][w+1]; //填充表格 for(int i=1; i&lt;=g.length; i++){ for(int j=1; j&lt;=w; j++){ if(j&lt;p[i-1]){ resultTable[i][j] = resultTable[i-1][j]; }else{ resultTable[i][j] = Math.max(resultTable[i-1][j], resultTable[i-1][j-p[i1]]+ g[i-1]); } } } //返回最后1个格子的值 return resultTable[g.length][w]; }//动态规划求解时间和空间都是是O(nw)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><pre class="line-numbers language-none"><code class="language-none">/*** 获得金矿最优收益* @param w 工人数量* @param p 金矿开采所需的工人数量* @param g 金矿储量*/public static int getBestGoldMiningV3(int w, int[] p, int[] g){//创建当前结果int[] results = new int[w+1]; //填充一维数组for(int i=1; i&lt;=g.length; i++){for(int j=w; j&gt;=1; j--){if(j&gt;=p[i-1]){results[j] = Math.max(results[j],results[j-p[i-1]]+ g[i-1]);}}}//返回最后1个格子的值return results[w];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在表格中除第1行之外，每 一行的结果都是由上一行数据 推导出来的。我们以4个金矿9个工 人为例。 4个金矿、9个工人的最优结果，是由它的两个最优子结构，也就是3个 金矿、5个工人和3个金矿、9个工人的结果推导而来的。这两个最优子 结构都位于它的上一行。 所以，在程序中并不需要保存整个表格，无论金矿有多少座，我们只保 存1行的数据即可。在计算下一行时，要从右向左统计（读者可以想想 为什么从右向左），把旧的数据一个一个替换掉。空间复杂度降低到了O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEO</title>
      <link href="/2021/12/08/qian-duan-kai-fa/seo/"/>
      <url>/2021/12/08/qian-duan-kai-fa/seo/</url>
      
        <content type="html"><![CDATA[<h2 id="SEO（搜索引擎优化）"><a href="#SEO（搜索引擎优化）" class="headerlink" title="SEO（搜索引擎优化）"></a>SEO（搜索引擎优化）</h2><p>网站排名分广告排前和免费排前，免费排前由百度的计算规则出你的网站的分数，分高者排前；</p><p>首先百度服务器派出蜘蛛来到你的网站进行来访抓取完成页面的收录，之后进行算法计算排名</p><h2 id="什么是蜘蛛？"><a href="#什么是蜘蛛？" class="headerlink" title="什么是蜘蛛？"></a>什么是蜘蛛？</h2><p>其实就是数据抓取的一串代码，各大搜索引擎都有，比如百度叫百度蜘蛛（baiduspider），必应叫必应蜘蛛，谷歌叫机器人；也就是爬虫；</p><p>爬虫到达你的网站会先模拟普通用户等操作，如果你的页面需要登录就很难被收录，最后带着数据返回，返回过程中进行初始计算，如果分数较低，之后往你这个网站的爬虫就会少，展示就会很低；</p><h2 id="网站爬虫管理规则"><a href="#网站爬虫管理规则" class="headerlink" title="网站爬虫管理规则"></a>网站爬虫管理规则</h2><p>链接尽可能为英文；</p><p>网站识别回访，其通俗的来说就是网站打开速度；</p><p>有效收录：收录越高，排行越高；</p><p>关键词，英文名叫Keywords，简单来说就是你这个网站希望别人通过什么词语搜索到你；</p><p>内容有价值：内容满足用户需要，内容优化文章关键字布局、关键字密度、内链、标题优化、描述、结构化数据等</p><h2 id="什么是内链和外链？"><a href="#什么是内链和外链？" class="headerlink" title="什么是内链和外链？"></a>什么是内链和外链？</h2><p>内链就是阅读文章时可以点击的链接或者说把网站串联起来的内部链接；</p><p>外链就是别人的文章里放的你的链接，然后点进来；</p><p>内链建设要有条理，顺其自然，外链就像如果你觉得本文对你有用，然后在写文章的时候插入了我的学习笔记的网址，那么就算是帮我做了一条自然外链，这种链接的效果是非常好的。如果有权威的网站也引用了你文章，并且留下了链接，那么可以算是起飞的效果了。</p><p>SEO各种工具：</p><ol><li><a href="https://soovle.com/">Soovle</a> 关键词分析，免费，可以给你自动生成多个网站用户的搜索相关词语。</li><li><a href="https://kwfinder.com/">KWFinder</a> 关键词分析，付费，可免费试用。</li><li><a href="https://moz.com/products/pro">MOZ</a> 多种SEO工具，付费，30天免费试用。</li><li><a href="https://ahrefs.com/zh/">ahrefs</a> 多种SEO工具，带中文，支持7天试用，很多人用这个。</li><li><a href="https://zh.semrush.com/">Semrush</a> 多种SEO工具，免费账号有限制，支持中文。</li><li><a href="https://answerthepublic.com/">Answerthepublic</a> 通过关键词分析用户经常搜索和提问的句子，带Pro版本。</li><li><a href="https://blog.naibabiji.com/files/wordpress-plugins/smart-keywords-tool.html">Smart Keywords Tool</a> 关键词挖掘插件，直接安装到WordPress网站上使用，带Pro版本。</li><li><a href="https://blog.naibabiji.com/files/baidu-tui-song.html">多合一搜索自动推送管理插件</a>，自动帮你通知百度、Google、Bing过来抓取你的文章，实现快速收录。</li></ol><p>请记住，<strong>SEO工具只是辅助，关键还是网站内容和基础的SEO优化。</strong></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>Google SEO的方法要跟着Google的规则不断学习和调整，搜索引擎每天都在进步，可能一些过时的教程已经并不实用了。如果你没精力去研究最新的Google SEO技巧，那么只需要记住你的内容是满足用户需求的，有价值的。那么不管规则怎么改动，你都不会受到太大的影响。</p></blockquote><p>最初建立博客是想记录自己的学习笔记，锻炼自己的知识总结能力，也便于复习和提升，后来觉得这反而给我一种激励打卡，督促着我去学习，SEO我没有做，也没有必要，这个网站就像是我一个人的小屋，一个人的孤岛，有人路过，愿意驻足也好不愿意也罢，我在这里书写着独属于我自己的故事，留下着专属于我的青春痕迹！</p><p>本文中参考来源：</p><ul><li><p>SEO学习教程：<a href="https://gitee.com/link?target=https://www.bilibili.com/video/BV1fE411J7ya">https://www.bilibili.com/video/BV1fE411J7ya</a></p></li><li><p><a href="https://blog.naibabiji.com/google-seo">Google SEO教程，谷歌搜索引擎优化新手入门指南 - 奶爸建站笔记 (naibabiji.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构习题</title>
      <link href="/2021/12/07/shu-ju-jie-gou-yu-suan-fa/shu-ju-jie-gou-xi-ti/"/>
      <url>/2021/12/07/shu-ju-jie-gou-yu-suan-fa/shu-ju-jie-gou-xi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ol><li><p>可以用 <strong>抽象数据类型</strong>定义一个完整的数据结构；</p><p>抽象数据类型（ADT）= 数据对象+数据关系+基本操作集</p></li><li><p>树是 <strong>非线性数据结构</strong>；</p><p>集合结构、树形结构、图形结构都是非线性的；</p><p>线性结构：N个数据的有序集合</p></li><li><p>属于逻辑结构的是 <strong>有序表</strong>；</p><p>有序表指关键字有序的线性表 ，可以链式也可以顺序，仅描述元素之间的关系</p></li><li><p>与数据的存储结构无关的是 <strong>栈</strong>；</p><p>数据结构三要素：存储结构（顺序存储、链接存储、索引存储、散列存储）；逻辑结构（线性表，队列，栈）；数据的运算</p><p>循环队列是一种用顺序表表示的特殊队列</p></li><li><p>数据的逻辑结构独立于其存储结构；</p></li><li><p>在存储数据时不仅要存储数据的值，还要 <strong>存储数据元素之间的关系</strong></p><p>储存数据时无需存储操作方法，存储数据结构时才需如此，其类型隐含于数据元素之中。</p></li><li><p>链式存储设计时，结点内的存储单元地址<strong>一定连续</strong></p><p>各个不同节点的存储空间可以不连续，但节点内的存储单元地址则必须连续；</p></li><li><p>对于两种不同的数据结构，逻辑结构或物理结构不一定相同。</p><p>例如：二叉树和二叉排序树是两种不同的数据结构，两者均可以使用二叉树的逻辑结构和物理结构，但是建立树、插入节点、删除节点等操作是不同的；</p></li><li><p>举例对相同的逻辑结构，同一种运算在不同存储方式实现，其运算效率不同；</p><p>线性表即可以用顺序存储方式、也可以用链式存储方式；</p><p>在顺序存储方式下，插入和删除时间复杂度为O（1）；</p><p>在链式存储方式下，插入和删除时间复杂度为O（1）；</p></li><li><p>程序是一组计算机能识别和执行的指令，算法是在有限时间内的解决问题完整的准确的一系列清晰指令。程序是算法在计算机上的特定的实现，程序不一定满足有穷性，而算法是有穷的确定的可行的输入输出</p></li><li><p>算法的时间复杂度是O（n**2），该算法执行时间和n方成正比；</p></li><li><p>```<br> void fun(int n){</p><pre><code> int i=1; while(i&lt;n){     i=i*2; }</code></pre><p> }<br>//求其时间复杂度<br>log2（n）；</p><pre class="line-numbers language-none"><code class="language-none">    计算时间复杂度方法    - 找出最深层循环内的语句    - 找出问题规模并确定关于n的函数式13. ```    int fun(int n){    if  (n&lt;=1) return 1;    return n*fun(n-1);    }    //求其时间复杂度    O（n）；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉堆和堆排序算法</title>
      <link href="/2021/12/07/shu-ju-jie-gou-yu-suan-fa/er-cha-dui-he-dui-pai-xu-suan-fa/"/>
      <url>/2021/12/07/shu-ju-jie-gou-yu-suan-fa/er-cha-dui-he-dui-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p>什么是二叉堆？ 二叉堆本质上是一种完全二叉树，它分为两个类型。 1. 最大堆。 2. 最小堆。 </p><p>什么是最大堆呢？最大堆的任何一个父节点的值，都大于或等于 它 左、右孩子节点的值</p><p>什么是最小堆呢？最小堆的任何一个父节点的值，都小于或等于它左、 右孩子节点的值。</p><p>二叉堆的根节点叫作堆顶 。 最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素 ；最小堆的堆顶是整个堆中的最小元素 。</p><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插 入一个新节点，值是 0。 这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节 点“上浮”，和父节点交换位置。 继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。 继续比较，最终新节点0“上浮”到了堆顶位置。 </p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆 顶的节点。例如删除最小堆的堆顶节点1。 这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临 时补到原本堆顶的位置。 接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果 左、右孩子节点中最小的一个（显然是节点2）比节点10小，那么让节 点10“下沉”。 继续让节点10和它的左、右孩子做比较，左、右孩子中最小的是节点 7，由于10大于7，让节点10继续“下沉”。 这样一来，二叉堆重新得到了调整。</p><h2 id="构建二叉堆"><a href="#构建二叉堆" class="headerlink" title="构建二叉堆"></a>构建二叉堆</h2><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是 让所有非叶子节点依次“下沉” 。 下面举一个无序完全二叉树的例子。 首先，从最后一个非叶子节点开始，也就是从节点10开始。如果节点10 大于它左、右孩子节点中最小的一个，则节点10“下沉”。 接下来轮到节点3，如果节点3大于它左、右孩子节点中最小的一个，则 节点3“下沉”。 然后轮到节点1，如果节点1大于它左、右孩子节点中最小的一个，则节 点1“下沉”。事实上节点1小于它的左、右孩子，所以不用改变。 接下来轮到节点7，如果节点7大于它左、右孩子节点中最小的一个，则 节点7“下沉”。 节点7继续比较，继续“下沉”。 经过上述几轮比较和“下沉”操作，最终每一节点都小于它的左、右孩子 节点，一个无序的完全二叉树就被构建成了一个最小堆。</p><p>二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉 堆的所有节点都存储在数组中</p><p>假设父节点的下标是parent，那么它的左孩子下标就是 2×parent+1 ；右 孩子下标就是2×parent+2 。</p><h1 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h1><ol><li><p>把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。 </p></li><li><p>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</p></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding: utf-8 -*-</span><span class="token triple-quoted-string string">"""Created on Wed Dec  8 21:38:45 2021@author: Binbincome"""</span><span class="token keyword">def</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>array<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 1.无序数组构建成最大堆</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        down_adjust<span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span>    <span class="token comment"># 2.循环交换集合尾部到堆顶，并调节堆产生新得堆顶</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 最后一个元素和第一个元素进行交换</span>        temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp        <span class="token comment"># 下沉调整最大堆</span>        down_adjust<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> array<span class="token punctuation">)</span>      <span class="token keyword">def</span> <span class="token function">down_adjust</span><span class="token punctuation">(</span>parent_index<span class="token punctuation">,</span> length<span class="token punctuation">,</span> array<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># temp保存父节点得值，最后赋值</span>    temp <span class="token operator">=</span> array<span class="token punctuation">[</span>parent_index<span class="token punctuation">]</span>    child_index <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>parent_index<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">while</span> child_index<span class="token operator">&lt;</span>length<span class="token punctuation">:</span>        <span class="token comment"># 如果有右孩子，且右大于左，定位到右</span>        <span class="token keyword">if</span> child_index<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>length <span class="token keyword">and</span> array<span class="token punctuation">[</span>child_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>array<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            child_index<span class="token operator">+=</span><span class="token number">1</span>        <span class="token comment"># 如果父节点值大于等于任何一个孩子得值就直接跳出</span>        <span class="token keyword">if</span> temp <span class="token operator">&gt;=</span> array<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token comment"># 无需真正交换，单向赋值即可    </span>        array<span class="token punctuation">[</span>parent_index<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span>        parent_index <span class="token operator">=</span> child_index        child_index <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>child_index<span class="token operator">+</span><span class="token number">2</span>            array<span class="token punctuation">[</span>parent_index<span class="token punctuation">]</span> <span class="token operator">=</span> temp    my_array <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">74</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>heap_sort<span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整体时间复杂度为O(nlog(n))</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉堆和堆排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS及其基本工作原理</title>
      <link href="/2021/12/05/qian-duan-kai-fa/dns-ji-qi-ji-ben-gong-zuo-yuan-li/"/>
      <url>/2021/12/05/qian-duan-kai-fa/dns-ji-qi-ji-ben-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h1><p>计算机在网络通讯时只能识别“192.168.1.1”之类的<strong>IP地址</strong>，而不能识别域名。记忆一串数字显然比有意义的英文字母简单，<strong>域名</strong>其实就是“<a href="http://www.zhihu.com”之类的.我们在平常访问网站时输入网站域名就能看见所需的页面是因为有一个叫做“**dns服务器**”的在替我们解析成了相应的ip地址,然后对应的服务器返回所需的信息./">www.zhihu.com”之类的。我们在平常访问网站时输入网站域名就能看见所需的页面是因为有一个叫做“**DNS服务器**”的在替我们解析成了相应的IP地址，然后对应的服务器返回所需的信息。</a></p><p>浏览时输入的是域名，域名和IP是绑定的，DNS服务器把英文的域名翻译成IP地址的过程被称为<strong>DNS域名解析</strong>；</p><p>顶级域名：test.com</p><p>二级域名：test.cn.com</p><p>三级域名：test.mail.cn.com</p><p>.com是一个域，表示一个区域或者说一个范围</p><h1 id="公网IP和私网IP"><a href="#公网IP和私网IP" class="headerlink" title="公网IP和私网IP"></a>公网IP和私网IP</h1><ul><li>全球需要上网的设备数量远远大于IP地址数量，因此IP地址不够用（指IPv4地址，IPv6地址够用）</li><li>所以在一个单位内部，需要使用私有IP地址组建网络，私有IP不能直接访问互联网，需要使用NAT地址转换网络技术才能访问互联网</li><li>简单说：要想让全世界的人都能访问你的服务器，你需要为服务器配置一个公网IP，如果没有，就需要使用NAT等网络技术</li></ul><pre class="line-numbers language-none"><code class="language-none">ipconfig -all//查看本机IP、子网掩码、等信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="子网掩码和网关"><a href="#子网掩码和网关" class="headerlink" title="子网掩码和网关"></a>子网掩码和网关</h1><blockquote><p>用来判断两台电脑之间是否能够直接通信</p></blockquote><ul><li>IP地址以“<strong>网络号</strong>”来判定两个主机是否处于同一个网络</li><li>我们把网络号相同的主机称之为本地网络主机，网络号不相同的主机称之为远程网络主机</li><li>本地网络中的主机可以直接相互通信，远程网络中的主机要相互通信必须通过网关（Gateway）来传递转发数据</li></ul><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><ul><li>一台拥有IP地址的主机可以提供许多服务，比如Web服务，FTP服务、SMTP服务等（每一个服务都对应一个应用程序）</li><li>那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过”IP地址+端口号”来区分不同的服务的</li><li>端口实行先占先得的规则，某个端口被占用了，其他应用程序就不能再重复占用，只能换端口</li></ul><h3 id="端口的分类和范围"><a href="#端口的分类和范围" class="headerlink" title="端口的分类和范围"></a>端口的分类和范围</h3><ul><li>常见端口分为TCP端口和UDP端口（TCP和UPD是不同的协议，详情请自行百度），每个都有65535个端口可供使用</li><li>TCP端口常见的包括FTP服务的21端口，Telent服务的23端口，SMTP服务的25端口，以及HTTP服务的80端口等</li><li>UDP端口常见的有DNS服务的53端口，SNMP（简单网络管理协议）服务的161端口，QQ使用的8000和4000端口等等</li></ul><h3 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h3><ul><li>20　ftp文件传输协议(默认数据口)　</li><li>21　ftp文件传输协议(控制)</li><li>22　Linux的SSH远程登录协议</li><li>80　http全球信息网超文本传输协议</li></ul><h3 id="查看端口命令"><a href="#查看端口命令" class="headerlink" title="查看端口命令"></a>查看端口命令</h3><p>可以使用Netstat命令：开始-&gt;运行，键入”cmd”并回车，打开命令提示符窗口。在命令提示符状态下键入</p><blockquote><p>netstat -a -n</p></blockquote><p>按下回车键后就可以看到以数字形式显示的 TCP和UDP连接的端口号及状态。</p><h1 id="DNS的解析过程（重点）"><a href="#DNS的解析过程（重点）" class="headerlink" title="DNS的解析过程（重点）"></a>DNS的解析过程（重点）</h1><blockquote><p><strong>DNS解析，</strong>又叫<strong>域名解析</strong>就是将域名解析为IP地址的过程。</p></blockquote><p>IP地址标志着网络中一个节点的位置，域名则是为了IP地址更容易被记住而设置的一个代称，域名解析由**<a href="https://www.zhihu.com/search?q=%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1820951002%7D">域名系统</a>（Domain Name System，简称DNS）<strong>来完成，可以把它看作是一个</strong>保存了域名和IP地址对应关系的数据库**。</p><ol><li>DNS解析是一个递归查找的过程，在用户访问“xxx.com”时，先向TCP/IP中设置的首选DNS服务器查询域名对应的IP地址（根据本地网络设置的不同而不同，这个DNS服务器又叫本地服务器），如果本地DNS服务器中恰好负责管理该记录或者缓存有该记录，则将结果IP地址返回给用户，域名解析结束。</li><li>如果本地DNS服务器中没有记录，则本地DNS服务器把请求转发给根DNS服务器，根DNS服务器会判断该地址的顶级域名（即“.com”）由哪台顶级<a href="https://www.zhihu.com/search?q=%E5%9F%9F%E5%90%8DDNS&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1820951002%7D">域名DNS</a>服务器负责，并将请求转发给对应的顶级域名DNS服务器。顶级<a href="https://www.zhihu.com/search?q=%E5%9F%9F%E5%90%8DDN&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1820951002%7D">域名DN</a>S服务器如果存有记录，则将其解析，如果不存有对应记录则继续转发给下一级的DNS服务器。最后找到对应IP地址返回给用户，域名解析结束。</li></ol><h1 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h1><p>用户通过计算机发起访问某域名时，</p><p>首先<strong>对DNS服务器发起请求</strong>：通过计算机所设置的DNS服务器通过私网IP被路由器NAT协议转换成的公网IP发起请求（可能还会有下一级的转换根据局域网的不同而不同，为了简单描述忽略部分过程。如果设置的是自动的话，就默认是路由器的DNS服务器）</p><p>DNS服务器根据域名先通过cache缓存在本地的记录查看是否存在对应IP，如果存在即返回IP地址，如果不存在就会向根服务器发送请求（根服务器储存着所有的顶级域名的IP地址，为了分担服务器压力一共有13台，后来随着任播等技术的出现,一切迎刃而解）根服务器返回给DNS服务器对应的顶级域名的IP地址，DNS服务器对顶级域名的服务器发起请求，顶级域名的服务器接受到请求后返回对应请求的域名的IP地址。到此域名解析结束！</p><h1 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h1><p>内容分发网络（Content Delivery Network，简称CDN）就使用DNS解析将用户的请求分配到了离用户最近的边缘节点上，进而提升了用户访问静态资源的速度。</p><p>在使用内容分发网络时，需要使用CNAME将源站域名指向CDN服务商指定的域名，而后者的解析由CDN服务商的DNS服务器负责。于是源站域名的最终解析权就交到了CDN服务商提供的DNS服务器手中。</p><p>CDN服务商的DNS服务器并不会简单地给出一个固定的IP地址，而是会根据用户请求的源IP等信息，寻找出一个距离当前用户最近的<a href="https://www.zhihu.com/search?q=CDN%E8%8A%82%E7%82%B9&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1820951002%7D">CDN节点</a>的IP后返回给用户。这样，用户解析源站的域名，拿到的却是CDN节点的地址。</p><p>之后，用户请求便前往该CDN节点获取内容。接下来CDN节点则会分析用户请求，如果是<a href="https://www.zhihu.com/search?q=%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1820951002%7D">静态资源</a>请求则由CDN节点直接返回，如果是<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1820951002%7D">动态资源</a>请求则由CDN节点转发给源站处理。</p><p>经过CDN服务商的处理，网络上众多的指向源站的请求实际已经被分散到了不同的CDN节点上。而对于用户而言，这一切是无法感知的，他们总感觉自己在访问同一个域名。</p>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器是怎么运作的</title>
      <link href="/2021/12/05/qian-duan-kai-fa/liu-lan-qi-shi-zen-me-yun-zuo-de/"/>
      <url>/2021/12/05/qian-duan-kai-fa/liu-lan-qi-shi-zen-me-yun-zuo-de/</url>
      
        <content type="html"><![CDATA[<p><strong>浏览器是运行在操作系统的应用程序</strong></p><h1 id="浏览器是个多进程结构，"><a href="#浏览器是个多进程结构，" class="headerlink" title="浏览器是个多进程结构，"></a>浏览器是个多进程结构，</h1><p>\1. 浏览器进程:控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作2.<br>\2. 缓存进程<br>\3. 网络进程 发起网络请求<br>\4. 渲染器进程  渲染Tab 有可能会为每个标签页是一个渲染进程<br>\5. GPU进程 渲染<br>\6. 插件进程  内置插件</p><h2 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h2><ol><li><p>浏览器通过网络请求后获取html数据，通过tcp传给渲染器进程</p></li><li><p>DOM - 主线程将html解析构造DOM树</p></li><li><p>style - 样式计算</p></li><li><p>layoutTree - dom+style 根据dom树和样式生成layoutTree</p></li><li><p>paint -绘制 通过遍历 Layout Tree生成绘制顺序表</p></li><li><p>laryer - 布局 然后根据主进程将layoutTree 和绘制信息表传给合成器线程</p></li><li><p>合成器线程 - 将得到的信息分图层分成更小的图块</p></li><li><p>栅格线程  -  将更小的图块进行栅格化raster，返还给合成器线程draw quads图块信息 存储在GPU中</p></li><li><p>frame 合成器将栅格线程返回的图块合成帧交给浏览器进程</p></li><li><p>浏览器进程 收到一帧的图像后传给GPU进行渲染</p></li></ol><h2 id="重排："><a href="#重排：" class="headerlink" title="重排："></a>重排：</h2><p>当改变dom的属性时，会重新进行样式计算，会重新布局和绘制<br>重绘：<br>当改变颜色时，只会发生样式计算和绘制(layer)<br>requestAnimationFrame()<br>会将主线程的任务分散到每一帧的间隔，从而不影响动画的流程<br>Fiber<br>react利用浏览器的空闲时间做优化<br>Transform<br>会直接运行合成器线程，所以不会感染主线程的渲染<br>在移动端使用3d转换可以优化性能（如果设备有3d加速引擎 GPU 可以提高性能 , 2d转换是无法调用GPU，2G是靠的CPU）</p>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http协议</title>
      <link href="/2021/12/05/qian-duan-kai-fa/http-xie-yi/"/>
      <url>/2021/12/05/qian-duan-kai-fa/http-xie-yi/</url>
      
        <content type="html"><![CDATA[<ul><li>底层知识永不过时！冲！</li><li>理解Http协议，动手试，</li><li>PHP+socket发http协议</li><li>PHP批量发帖，防盗链；</li></ul><h2 id="HTTP协议概念和工作流程"><a href="#HTTP协议概念和工作流程" class="headerlink" title="HTTP协议概念和工作流程"></a>HTTP协议概念和工作流程</h2><p>计算机中的协议就像生活中的协议一样，一式双份，双方都遵循这个规范！计算机能全世界互通计算机协议功不可没。类似的还有ftp、http、stmp、pop、tcp/ip等协议。</p><p>当你打开一个页面时，客户端就发送请求和服务器建立连接；</p><p>服务器就沿着连接，返回响应信息；</p><p>客户端收到响应的html代码解析出图片和文字组成页面呈现出来</p><h2 id="http协议请求方法"><a href="#http协议请求方法" class="headerlink" title="http协议请求方法"></a>http协议请求方法</h2><table><thead><tr><th>1</th><th>GET</th><th>请求指定的页面信息，并返回实体主体。</th></tr></thead><tbody><tr><td>2</td><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td>4</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>5</td><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>6</td><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>7</td><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>9</td><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="cmd发起请求："><a href="#cmd发起请求：" class="headerlink" title="cmd发起请求："></a>cmd发起请求：</h2><ul><li>ipconfig查看ip</li><li>telnet localhost 80  //连接本地端口</li><li>ctrl+】打开回显</li><li>输入客户端请求消息</li><li>得到服务器响应消息</li></ul><h3 id="请求消息："><a href="#请求消息：" class="headerlink" title="请求消息："></a>请求消息：</h3><p><strong>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成</strong></p><blockquote><p>请求行=请求方法+请求路径+协议版本</p><p>请求头=key+value</p><p>空行                       //这个千万不能省略，这是用来区分请求消息和请求数据的，没有请求数据时可以为空</p><p>请求数据                //也可以为空</p></blockquote><p>例子如下：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">GET /hello.txt HTTP/1.1    User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="响应消息："><a href="#响应消息：" class="headerlink" title="响应消息："></a>响应消息：</h3><p><strong>状态行、消息报头、空行和响应正文</strong></p><blockquote><p>状态行 = 协议版本+状态码+状态</p><p>消息报头=key+value</p><p>空行</p><p>响应正文</p></blockquote><p>例子如下：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: "34aa387-d-1568eb00"Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP 状态码的英文为 <strong>HTTP Status Code</strong>。。</p><p>下面是常见的 HTTP 状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><p><strong>程序员最想看到的：200-OK。</strong></p><p><strong>程序员不想看到的：500-Internal-Server-Error</strong></p><p>本文学习引用自：</p><ul><li><a href="https://www.runoob.com/http/http-tutorial.html">https://www.runoob.com/http/http-tutorial.html</a></li><li><a href="https://www.bilibili.com/video/BV1js411g7Fw">https://www.bilibili.com/video/BV1js411g7Fw</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭秘阿里云服务器</title>
      <link href="/2021/12/05/qian-duan-kai-fa/jie-mi-a-li-yun-fu-wu-qi/"/>
      <url>/2021/12/05/qian-duan-kai-fa/jie-mi-a-li-yun-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云服务器（ECS）"><a href="#阿里云服务器（ECS）" class="headerlink" title="阿里云服务器（ECS）"></a>阿里云服务器（ECS）</h1><p>知识点；</p><ul><li>阿里云服务器的简介</li><li>阿里云服务器的使用</li><li>云服务器安装JDK、Tomcat等软件</li><li>部署项目</li></ul><p>等买了服务器再来学这个视频吧！</p><p>揭秘阿里云服务器：<a href="https://www.bilibili.com/video/BV1Rt411u7k4">https://www.bilibili.com/video/BV1Rt411u7k4</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习01</title>
      <link href="/2021/12/04/linux/linux-xue-xi-01/"/>
      <url>/2021/12/04/linux/linux-xue-xi-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a><strong>什么是Linux</strong></h2><p>人们日常在Windows上访问的百度、谷歌、淘宝、qq、迅雷等软件，支撑这些软件运行的，后台是成千上万的Linux服务器，它们时时刻刻进行着忙碌的数据处理和运算。通常服务器使用LAMP（Linux + Apache + MySQL + PHP）或LNMP（Linux + Nginx+ MySQL + PHP）<strong>在Linux的世界里一切皆文件</strong>！</p><h2 id="Linux背景"><a href="#Linux背景" class="headerlink" title="Linux背景"></a><strong>Linux背景</strong></h2><p>两个开发了C语言的大佬编写了unix，然后不同公司开发了不同的发行版并要付费使用，然后咧，<strong>林纳斯·托瓦兹（Linus Torvalds）</strong>基于unix编写Linux，响应斯托曼的GNU计划开源了代码，这个就是后来的Linux内核，后来由世界上无数个爱好者共同贡献修改，才有了现在好用的Linux，<strong>开源精神</strong>yyds！</p><h2 id="VMware和Centos7"><a href="#VMware和Centos7" class="headerlink" title="VMware和Centos7"></a>VMware和Centos7</h2><p>VMware可以在window中安装虚拟机，使用虚拟机来安装Linux，除了安装方便简单，也不怕讲电脑系统搞坏，无论你怎么玩，也不怕Linux坏掉，因为vmware可以快照！可以重新安装，多玩坏几次你就是装机大神了！</p><p>Linux有不少发行版，使用最多的是Centos以及Unbantu。</p><p>省略安装过程，因为随便百度或哔哩哔哩搜索就有详细的安装教程！</p><p>Centos7可以直接在windows和虚例机间复制粘贴文件，无需安装vmtools等，共享文件夹可以直接设置！</p><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>不同于Windows中的C、D盘的概念，在Linux底下，所有的文件与目录都是由根目录开始，是目录与文件的源头，然后一个个的分支下来，如同树枝状，因此称为这种目录配置为：<strong>目录树</strong>。</p><p>远程连接或开启虚例机进入Linux后输入</p><blockquote><p>ls /      查看根目录下的文件目录<br>ls        显示当前所在位置的目录，如果所在位置没有文件就不会显示</p><p>pwd   显示当前所在位置</p></blockquote><p>根目录树下常见文件夹说明，<strong>有些文件目录不能轻易改动！</strong></p><ul><li><p><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>/opt</strong>：<br>这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/selinux</strong>：<br>这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>/srv</strong>：<br>该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：<br>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p><p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p></li></ul><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><ul><li><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：<br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong>内核源代码默认的放置目录。</li><li><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li></ul><h2 id="Xshell和Xftp"><a href="#Xshell和Xftp" class="headerlink" title="Xshell和Xftp"></a>Xshell和Xftp</h2><p>远程登录时少用root登录避免操作失误，一般是普通用户登录，用<strong>su - 用户名</strong> 切换成系统管理员，<strong>exit</strong>即可注销用户；运行级别概念之后补充；</p><ul><li><p>Xshell来远程登录项目管理和操作【解决了中文乱码问题，而且很流畅】</p><p>新键会话就是新键一个连接，主机名就是填要远程控制的Linux的ip地址，端口号选22，</p></li><li><p>Xftp远程上传下载文件</p><p>协议要选SFTP，端口号也是22，如果乱码就在选项中更改为UTF-8就行</p></li></ul><h2 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h2><p>一般Linux都自带vi，vim可以认为是vi的增强版，vim有三种模式。</p><h3 id="命令模式-正常模式"><a href="#命令模式-正常模式" class="headerlink" title="命令模式/正常模式"></a><strong>命令模式/正常模式</strong></h3><p>一般在Linux中输入</p><blockquote><p><strong>vim 文件名</strong></p></blockquote><p>默认进入命令模式，在命令模式的输入都会被识别为命令输入，通过命令或快捷键我们可以对文件进行一些操作，常用命令如下：</p><blockquote><p><strong>i</strong> 按i进入到插入模式/编辑模式，以输入字符。</p><p><strong>x</strong> 删除当前光标所在处的字符。</p><p><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</p><p>wq 退出vim编辑器</p></blockquote><h3 id="编辑模式-插入模式"><a href="#编辑模式-插入模式" class="headerlink" title="编辑模式/插入模式"></a><strong>编辑模式/插入模式</strong></h3><p>在命令模式中按i进入编辑模式，在编辑模式下常用快捷键如下：</p><blockquote><p><strong>字符按键以及Shift组合</strong>，输入字符</p><p><strong>ENTER</strong>，回车键，换行</p><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p><p><strong>DEL</strong>，删除键，删除光标后一个字符</p><p><strong>方向键</strong>，在文本中移动光标</p><p><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</p><p><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</p><p><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</p><p><strong>ESC</strong>，退出输入模式，切换到命令模式</p></blockquote><h3 id="命令行模式-底线命令模式"><a href="#命令行模式-底线命令模式" class="headerlink" title="命令行模式/底线命令模式"></a>命令行模式/底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！</p><ul><li><strong>q</strong> 退出程序</li><li><strong>w</strong> 保存文件</li><li><strong>：set nu</strong> 可以显示行号</li><li><strong>：set nonu</strong> 取消行号</li><li>g 到文件最后一行，gg 到文件首行，u回退上一个步骤</li><li>dd删除，yy拷贝，+数字表示操作光标下面多少行</li></ul><p>按ESC键可随时退出底线命令模式</p><p>Vim键盘图：<a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全Vim快捷键键位图（入门到进阶） | 菜鸟教程 (runoob.com)</a></p><h2 id="开机、重启命令"><a href="#开机、重启命令" class="headerlink" title="开机、重启命令"></a>开机、重启命令</h2><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。</p><p>例如你可以运行如下命令关机：</p><blockquote><p>sync 将数据由内存同步到硬盘中。</p><p>shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</p><p>shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</p><p>shutdown –h now 立马关机</p><p>shutdown –h 20:25 系统会在今天20:25关机</p><p>shutdown –h +10 十分钟后关机</p><p>shutdown –r now 系统立马重启</p><p>shutdown –r +10 系统十分钟后重启</p><p>reboot 就是重启，等同于 shutdown –r now</p><p>halt 关闭系统，等同于shutdown –h now 和 poweroff</p></blockquote><p>疑问：</p><blockquote><p>有的弹幕说重启以后没法连接了，视频里老师也有这个情况，是Linux重启过后主机ip地址改变了吗？</p><p>在虚拟机中输入shutdown命令没有用，只有root才有权限；</p></blockquote><p>总结：</p><blockquote><p>关机和重启前都应该先sync一下；</p></blockquote><p>参考文章：<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">Linux 的启动流程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Linux系统下每一个用户至少属于一个组，包括root也在组里，只不过是root组，组的概念弹幕有说就像是用户池。</p><p>家目录/home，普通用户登录时会自动进入到自己的家目录比如/home/用户名。</p><p>常用命令：</p><blockquote><p>useradd [选项] 用户名    ，会自动创建家目录，组名和用户名相同</p><p>useradd -d 指定目录 新的用户名      ，给新创建的用户指定家目录</p><p>passwd 用户名    ，给用户指定或修改密码</p><p>userdel 用户名    ，仅删除用户，家目录还在</p><p>userdel -r 用户名     ，用户和家目录都删</p></blockquote><p>在实际工作中家目录一般不删</p><p>用户组命令：</p><blockquote><p>  groupadd 组名   ，增加组名</p><p>  groupdel 组名    ，删除组名</p><p>  usermod -g 用户组 用户名     ，将用户名对应的用户修改到对应的用户组里去</p></blockquote><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><p>之后在慢慢填坑吧，这个文件还需要完善！</p><h1 id="终极奥义：rm-rf-删库跑路"><a href="#终极奥义：rm-rf-删库跑路" class="headerlink" title="终极奥义：rm -rf/* 删库跑路"></a>终极奥义：rm -rf/* 删库跑路</h1>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习复习</title>
      <link href="/2021/12/02/qian-duan-kai-fa/javascript-xue-xi-fu-xi/"/>
      <url>/2021/12/02/qian-duan-kai-fa/javascript-xue-xi-fu-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript（简称JS）和Java没有任何关系。</p><p>HTML为骨，CSS为皮，JS为动作合在一起就是浏览器里我们浏览页面所看到的样子。</p><p>复习内容如下：</p><ul><li>JavaScript，他和Python一样是一门编程语言，而浏览器内置了JavaScript语言的解释器，所以JavaScript代码在浏览器上就可以运行。</li><li>DOM，（Document Object Model）是指文档对象模型，通过它，可以操作HTML文档的相关功能，例如：对标签内容进行删除和替换等。</li><li>BOM，（Browser Object Model）是指浏览器对象模型，通过他，可以操作浏览器相关的功能，例如：浏览器设置定时器，浏览器定时刷新页面。</li></ul><h2 id="JS在开发中的运用"><a href="#JS在开发中的运用" class="headerlink" title="JS在开发中的运用"></a>JS在开发中的运用</h2><ul><li>如果代码量比较少，而且是只在当前页面使用的话，最好放在body标签底部，因为浏览器在解析HTML、CSS、JavaScript文件时，是按照从上到下逐步解释并执行，如果JavaScript代码或文件放在head中可能会有因为耗时（网络请求或代码）导致页面显示速度太慢，影响用户感受。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>    <span class="token comment">/*老旧的实例可能会在 &lt;script&gt; 标签中使用 type="text/javascript"。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言。*/</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果代码量比较多，需要分离出来为单独的js文件。这样不仅可以被多个引用，避免重复编写。</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>JavaScript中变量的声明是一个非常容易出错的点，局部变量必须一个 var 开头，如果未使用var，则默认表示声明的是全局变量。</p><pre class="line-numbers language-none"><code class="language-none">&lt;script type="text/javascript"&gt;    // 全局变量    name = '武沛齐';    function func(){        // 局部变量        var age = 18;        // 全局变量        gender = "男"    }    func();    console.log(gender); // 男    console.log(name); // 武沛齐    console.log(age); // 报错：age是fun的局部变量，外部无法获取。&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h4><h5 id="1-数字（Number）"><a href="#1-数字（Number）" class="headerlink" title="1. 数字（Number）"></a>1. 数字（Number）</h5><p>JavaScript中不区分整数值和浮点数值，JavaScript中所有数字均用浮点数值表示。</p><pre class="line-numbers language-none"><code class="language-none">// 声明var page = 111;var age = Number(18);var a1 = 1,a2 = 2, a3 = 3;// 转换parseInt("1.2");  // 将某值转换成数字，不成功则NaNparseFloat("1.2");  // 将某值转换成浮点数，不成功则NaN/*NaN，非数字。可使用 isNaN(num) 来判断。Infinity，无穷大。可使用 isFinite(num) 来判断。*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展：可以用 typeof(“xx”) 查看数据类型。</p><h5 id="2-字符串-String"><a href="#2-字符串-String" class="headerlink" title="2. 字符串(String)"></a>2. 字符串(String)</h5><pre class="line-numbers language-none"><code class="language-none">// 声明var name = "wupeiqi";var name = String("wupeiqi");var age_str = String(18);// 常用方法var name = "wupeiqi";var value = names[0]                    // 索引var value = name.length                 // 获取字符串长度var value = name.trim()                 // 去除空白var value = name.charAt(index)          // 根据索引获取字符var value = name.substring(start,end)   // 根据索引获取子序列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-布尔类型（Boolean）"><a href="#3-布尔类型（Boolean）" class="headerlink" title="3. 布尔类型（Boolean）"></a>3. 布尔类型（Boolean）</h5><p>布尔类型仅包含真假，与Python不同的是其首字母小写。</p><pre class="line-numbers language-none"><code class="language-none">var status = true;var status = false;/*在js中进行比较时，需要注意：    ==       比较值相等    !=       不等于    ===      比较值和类型相等    !===     不等于    ||        或    &amp;&amp;        且*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-数组（Array）"><a href="#4-数组（Array）" class="headerlink" title="4. 数组（Array）"></a>4. 数组（Array）</h5><p>JavaScript中的数组类似于Python中的列表。</p><pre class="line-numbers language-none"><code class="language-none">// 常见方法var names = ['武沛齐', '肖峰', '于超']names[0]                        // 索引names.push(ele)                 // 尾部追加元素var ele = names.obj.pop()       // 尾部移除一个元素names.unshift(ele)              // 头部插入元素var ele = obj.shift()           // 头部移除一个元素names.splice(index,0,ele)       // 在指定索引位置插入元素names.splice(index,1,ele)       // 指定索引位置替换元素names.splice(index,1)           // 指定位置删除元素names.slice(start,end)          // 切片names.reverse()                 // 原数组反转names.join(sep)                 // 将数组元素连接起来以构建一个字符串names.concat(val,..)            // 连接数组names.sort()                    // 对原数组进行排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-字典（对象Object）"><a href="#5-字典（对象Object）" class="headerlink" title="5. 字典（对象Object）"></a>5. 字典（对象Object）</h5><p>JavaScript中其实没有字典类型，字典是通过对象object构造出来的。</p><pre class="line-numbers language-none"><code class="language-none">// 声明info = {    name:'武沛齐',    "age":18}// 常用方法var val = info['name']      // 获取info['age'] = 20            // 修改info['gender'] = 'male'     // 新增delete info['age']          // 删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="json-序列化"><a href="#json-序列化" class="headerlink" title="json 序列化"></a>json 序列化</h4><p>JavaScript提供了json序列化功能，即：将对象和字符串之间进行转换。网络中数据传输本质上是基于字符串进行，如果想要把一个js的对象通过网络发送到某个网站，就需要对对象进行序列化然后发送。</p><ul><li><p>JSON.stringify(object) ，序列化</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> info <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'alex'</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">,</span>girls<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'钢弹'</span><span class="token punctuation">,</span><span class="token string">'铁锤'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">var</span> infoStr <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>infoStr<span class="token punctuation">)</span> # <span class="token string">'{"name":"alex","age":19,"girls":["钢弹","铁锤"]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>JSON.parse(str)，反序列化</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> infoStr <span class="token operator">=</span> <span class="token string">'{"name":"alex","age":19,"girls":["钢弹","铁锤"]}'</span><span class="token keyword">var</span> info <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>infoStr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型（Document Object Model，DOM）是一种用于HTML编程接口。它给文档提供了一种结构化的表示方法，可以改变文档的内容和呈现方式。更直白一点讲：DOM相当于是一个模块，提供了关于HTML文档中对标签进行操作的功能，JavaScript结合DOM可以对HTML中的标签进行操作。</p><h3 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1.选择器"></a>1.选择器</h3><ul><li>直接查找</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>             <span class="token comment">// 根据ID获取一个标签对象</span>document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>     <span class="token comment">// 根据class属性获取标签对象集合</span>document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>       <span class="token comment">// 根据name属性值获取标签对象集合</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>       <span class="token comment">// 根据标签名获取标签对象集合</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>间接查找</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> tag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>tag<span class="token punctuation">.</span>parentElement           <span class="token comment">// 找当前标签对象的父标签对象</span>tag<span class="token punctuation">.</span>children                <span class="token comment">// 找当前标签对象的所有子标签对象</span>tag<span class="token punctuation">.</span>firstElementChild       <span class="token comment">// 找当前标签对象的第一个子标签对象</span>tag<span class="token punctuation">.</span>lastElementChild        <span class="token comment">// 找当前标签对象最后一个子标签对象</span>tag<span class="token punctuation">.</span>nextElementtSibling     <span class="token comment">// 找当前标签对象下一个兄弟标签对象</span>tag<span class="token punctuation">.</span>previousElementSibling  <span class="token comment">// 找当前标签对象上一个兄弟标签对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-事件"><a href="#2-事件" class="headerlink" title="2.事件"></a>2.事件</h4><p>DOM中可以为标签设置事件，给指定标签绑定事件之后，只要对应事件被处罚，就会执行对应代码。常见事件有：</p><ul><li><code>onclick</code>，单击时触发事件</li><li><code>ondblclick</code>，双击触发事件</li><li><code>onchange</code>，内容修改时触发事件</li><li><code>onfocus</code>，获取焦点时触发事件</li><li><code>onblur</code>，失去焦点触发事件</li></ul><h4 id="3-值操作"><a href="#3-值操作" class="headerlink" title="3.值操作"></a>3.值操作</h4><p>值操作针对与用户交互相关的标签，其中内部使用value属性进行操作。</p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>BOM（Browser Object Model）是指浏览器对象模型，通过他，可以操作浏览器相关的功能。更直白一点讲：BOM相当于是一个模块，提供了关于浏览器操作的功能。</p><h4 id="1-提示框"><a href="#1-提示框" class="headerlink" title="1.提示框"></a>1.提示框</h4><ul><li><code>alert</code>，提示框。</li><li><code>confirm</code>，确认框。</li></ul><h4 id="2-浏览器URL"><a href="#2-浏览器URL" class="headerlink" title="2.浏览器URL"></a>2.浏览器URL</h4><ul><li><code>location.href</code>，获取当前浏览器URL。</li><li><code>location.href = "url"</code>，设置URL，即：重定向。</li><li><code>location.reload()</code>，重新加载，即：刷新页面。</li></ul><h4 id="3-定时器"><a href="#3-定时器" class="headerlink" title="3.定时器"></a>3.定时器</h4><ul><li><code>setInterval(function(){},1000)</code>，创建多次定时器。</li><li><code>clearInterval(定时器对象)</code>，删除多次定时器。</li><li><code>setTimeout(function(){},1000)</code>，创建单次定时器。</li><li><code>clearTimeout(定时器对象)</code>，删除单次定时器。</li></ul><p>本文节选自<a href="https://pythonav.com/%EF%BC%8C%E5%A6%82%E6%9E%84%E6%88%90%E4%BE%B5%E6%9D%83%EF%BC%8C%E8%81%94%E7%B3%BB%E5%BF%85%E5%88%A0%EF%BC%8C%E4%BB%85%E4%BD%9C%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E6%89%80%E7%94%A8%EF%BC%8C%E5%A6%82%E6%9C%89%E9%94%99%E8%AF%AF%EF%BC%8C%E6%AC%A2%E8%BF%8E%E8%81%94%E7%B3%BB%E6%9B%B4%E6%AD%A3%EF%BC%81">https://pythonav.com/，如构成侵权，联系必删，仅作个人学习记录所用，如有错误，欢迎联系更正！</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表和哈希函数</title>
      <link href="/2021/12/02/shu-ju-jie-gou-yu-suan-fa/ha-xi-biao-he-ha-xi-han-shu/"/>
      <url>/2021/12/02/shu-ju-jie-gou-yu-suan-fa/ha-xi-biao-he-ha-xi-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h1><blockquote><p>哈希表（hash table）也叫作散列表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作。散列表通过哈希函数实现 Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突。散列表这种数据结构提供了键（Key）和值（Value） 的映射关系。只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于O(1) 。</p></blockquote><h1 id="什么是哈希函数？"><a href="#什么是哈希函数？" class="headerlink" title="什么是哈希函数？"></a>什么是哈希函数？</h1><blockquote><p>本质上哈希表其实也是数组，数组只能根据下标，像a[0]、a[1]、 a[2]、a[3]、a[4]这样来访问，而散列表的Key则是以字符串类型为 主的。需要一个“中转站”，通过某种方式，把Key和数组下标进行转换。这个中转站就叫作哈希函数。</p></blockquote><h1 id="哈希函数的实现"><a href="#哈希函数的实现" class="headerlink" title="哈希函数的实现"></a>哈希函数的实现</h1><p>在不同的语言中，哈希函数的实现方式是不一样的。以Java的常用集合HashMap为例。 在Java及大多数面向对象的语言中，每一个对象都有属于自己的hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的 类型是什么，它们的hashcode都是一个整型变量。 既然都是整型变量，想要转化成数组的下标也就不难实现了。最简单的转化方式是什么呢？是按照数组长度进行取模运算。</p><blockquote><p>index = HashCode (Key) % Array.length </p></blockquote><p>实际上，JDK（Java Development Kit，Java语言的软件开发工具包）中 的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化性能。不过可以姑且简单理解成取模操作。通过哈希函数，我们可以把字符串或其他类型的Key，转化成数组的下标index。</p><p>如给出一个长度为8的数组，则当 key=001121时，</p><blockquote><p>index = HashCode (“001121”) % Array.length = 1420036703 % 8 = 7 </p></blockquote><p>而当key=this时，</p><blockquote><p>index = HashCode (“this”) % Array.length = 3559070 % 8 = 6</p></blockquote><h1 id="哈希表中的读写操作"><a href="#哈希表中的读写操作" class="headerlink" title="哈希表中的读写操作"></a>哈希表中的读写操作</h1><p>写操作</p><ul><li>第1步，通过哈希函数，把Key转化成数组下标5。 </li><li>第2步，如果数组下标5对应的位置没有元素，就把这个Entry填充到数 组下标5的位置</li></ul><p>读操作</p><h1 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="headerlink" title="什么是哈希冲突"></a>什么是哈希冲突</h1><blockquote><p>在散列表写操作时，由于数组的长度是有限的，当插入的Entry越来越多时，不同的 Key通过哈希函数获得的下标有可能是相同的。例如002936这个Key对应的数组下标是2；002947这个Key对应的数组下标也是2。这种情况，就叫作哈希冲突 </p></blockquote><h1 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h1><ul><li><p>开放寻址法，</p><p>开放寻址法的原理很简单，当一个Key通过哈希函数获得对应的数组下 标已被占用时，我们可以“另谋高就”，寻找下一个空档位置。</p></li><li><p>链表法。 </p><p>Java的集合类HashMap当中。 HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节 点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的 Entry映射到与之冲突的数组位置时，需要插入到对应的链表中</p></li></ul><p>链表法比较重要，所以讲讲链表法实现步骤如下</p><ul><li>第1步，通过哈希函数，把Key转化成数组下标2。</li><li> 第2步，找到数组下标2所对应的元素，如果这个元素的Key是002936， 那么就找到了；如果这个Key不是002936也没关系，由于数组的每个元素都与一个链表对应，可以顺着链表慢慢往下找，看看能否找到与 Key相匹配的节点。</li></ul><p>注意：关于HashMap的实现，JDK 8和以前的版本有着很大的 不同。当多个Entry被Hash到同一个数组下标位置时，为了提升插入和查找的效率，HashMap会把Entry的链表转化为红黑树这种数据结构。由于散列表的具体实现代码比较复杂，所以有兴趣自己去看看源码吧嘿嘿。</p><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>Hash算法是一个广义的算法，也可以认为是一种思想，使用Hash算法可以提高存储空间的利用率，可以提高数据的查询效率，也可以做数字签名来保障数据传递的安全性。所以Hash算法被广泛地应用在互联网应用中。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序算法</title>
      <link href="/2021/12/01/shu-ju-jie-gou-yu-suan-fa/mou-pao-pai-xu-suan-fa/"/>
      <url>/2021/12/01/shu-ju-jie-gou-yu-suan-fa/mou-pao-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序算法的实现以及优化"><a href="#冒泡排序算法的实现以及优化" class="headerlink" title="冒泡排序算法的实现以及优化"></a>冒泡排序算法的实现以及优化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>冒泡排序核心内容：</p><p>相邻元素间两两比较，当一个元素大于右侧相邻元素时，交换它们的位置，如果是小于或等于的话就位置不变。本篇文章主要使用python语言实现最基础的冒泡排序语言以及算法优化，内容均来源于网络或书籍，侵权必删，如有疏漏欢迎评论指出！路漫漫其修远兮, 吾将上下而求索. 望与各位读者共勉!</p><h2 id="冒泡排序算法基础v1版"><a href="#冒泡排序算法基础v1版" class="headerlink" title="冒泡排序算法基础v1版"></a>冒泡排序算法基础v1版</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort_v1</span><span class="token punctuation">(</span>array<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>temp my_array <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">]</span><span class="token punctuation">)</span>bubble_sort_v1<span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="冒泡排序算法优化v2版"><a href="#冒泡排序算法优化v2版" class="headerlink" title="冒泡排序算法优化v2版"></a>冒泡排序算法优化v2版</h2><p>有时经过数次排序后，整个数列已经是有序的了，但V1版还是会傻傻的执行，可以利用is_sorted作为标记，如果在本轮排序中元素有交换，说明数列无序；如果有无元素交换，则说明数列已经有序，直接跳出循环。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort_v2</span><span class="token punctuation">(</span>array<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 有序标记，每轮初始是True</span>        is_sorted <span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>temp                 <span class="token comment"># 有元素交换的话就不是有序的，标记变为False</span>                is_sorted <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> is_sorted<span class="token punctuation">:</span>                <span class="token keyword">break</span>            my_array <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">]</span><span class="token punctuation">)</span>bubble_sort_v2<span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="冒泡排序算法v3版"><a href="#冒泡排序算法v3版" class="headerlink" title="冒泡排序算法v3版"></a>冒泡排序算法v3版</h2><p>每一轮排序后，最后或最前的元素属于有序区，其他为无序区，按照现有逻辑每一轮排序后有序区长度加一，但实际上，数列的真正的有序区可能已经不只这个长度，而有序区的多次比较是毫无意义的。</p><p>解决方案：在每轮排序后记录下最后一次元素交换的位置，该位置就是无序数列的边界，分割有序和无序区。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort_v3</span><span class="token punctuation">(</span>array<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 记录最后一次交换的位置</span>    last_exchange_index <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 无序数列的边界，每次只需比较到这</span>    sort_border <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 有序标记，每轮初始是True</span>        is_sorted <span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sort_border<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>temp                 <span class="token comment"># 有元素交换的话就不是有序的，标记变为False</span>                is_sorted <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token comment"># 把无序数列的边界更新为最后一次交换元素的位置</span>                last_exchange_index <span class="token operator">=</span> j        sort_border <span class="token operator">=</span> last_exchange_index        <span class="token keyword">if</span> is_sorted<span class="token punctuation">:</span>                <span class="token keyword">break</span>            my_array <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">]</span><span class="token punctuation">)</span>bubble_sort_v3<span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>冒泡排序的每一轮都是从左到右比较元素并进行单向的位置交换就像气泡一样一个接着一个向上冒泡，而鸡尾酒排序的比较就像钟摆一样，元素的比较和交换是双向的。比如{2，3，4，5，6，7，8，1}这种已经有部分是有着相对规律的数列如果使用冒泡排序可能需要7轮的比较，而使用鸡尾酒排序只需要3轮。</p><p>在大部分元素已经是有序的情况下，鸡尾酒排序能够有效的减少排序的次数，缺点在于代码量几乎增加了一倍。个人认为鸡尾酒排序就像是鸡肋一般，排序本身就是为了将大量的无序的数据进行排列，而鸡尾酒排序只有在特定的情况下才能使用，关于鸡尾酒排序的实现以及优化有兴趣的朋友可以自行探索啦。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找和排序之快速排序</title>
      <link href="/2021/12/01/shu-ju-jie-gou-yu-suan-fa/cha-zhao-he-pai-xu-zhi-kuai-su-pai-xu/"/>
      <url>/2021/12/01/shu-ju-jie-gou-yu-suan-fa/cha-zhao-he-pai-xu-zhi-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="查找和排序之快速排序"><a href="#查找和排序之快速排序" class="headerlink" title="查找和排序之快速排序"></a>查找和排序之快速排序</h1><h2 id="查找和排序的关系是什么？"><a href="#查找和排序的关系是什么？" class="headerlink" title="查找和排序的关系是什么？"></a>查找和排序的关系是什么？</h2><blockquote><p>排序，是指将一系列无序的记录，通过某种方式或者算法，将其变为有序的过程。</p><p>查找，是指在某些特定的数据结构中，对给定的值（key），进行查找相应位置的过程。</p><p>排序是查找的前提，排序算法的优劣影响着查找的效率！</p></blockquote><h2 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h2><blockquote><p>同一种逻辑结构，无论该逻辑结构物理存储是啥，都可以执行相同的操作；</p><p>就是编写模板代码来适应任意类型，泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p></blockquote><h2 id="什么是快速排序？"><a href="#什么是快速排序？" class="headerlink" title="什么是快速排序？"></a>什么是快速排序？</h2><blockquote><p>快速排序是从冒泡排序中演变过来的算法，但它不同于冒泡排序的是采用的是分治法（每一轮选取一个基准元素，并让比它的大的元素移到一边，比它小的元素移到一边，从而把数列拆解成两个部分），如果是简单的选取第一个元素作为基准元素，当希望将一个逆序的数列排列成顺序的时候，时间复杂度由O（n*logn）退化成了O（n**2），随机的选取一个元素，并让它和首项交换位置可以减少遇到这种情况。选定了基准元素以后，我们要做的就是把其他元素中小于基准元素的都交换到基准元素一边，大于基准元素的都交换到基准元素另一边。 具体如何实现呢？有两种方法。 </p><ul><li>双边循环法</li><li>单边循环法</li></ul></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">//双边循环法C语言代码实现# include &lt;stdio.h&gt;int FindPos(int * a, int low, int high);void QuickSort(int * a, int low, int high);int main(void){int a[6] = {-1, 89, 0, -23, 678, -43};int i;QuickSort(a, 0, 5); //第二个参数表示第一个元素的下标  第三个参数表示最后一个元素的下标for (i=0; i&lt;6; ++i)printf("%d  ", a[i]);printf("\n");return 0;}void QuickSort(int * a, int low, int high){int pos;if (low &lt; high){pos = FindPos(a, low, high);QuickSort(a, low, pos-1);QuickSort(a, pos+1, high);}}int FindPos(int * a, int low, int high){int val = a[low];while (low &lt; high){while (low&lt;high  &amp;&amp; a[high]&gt;=val)--high;a[low] = a[high];while (low&lt;high &amp;&amp; a[low]&lt;=val)++low;a[high] = a[low];}//终止while循环之后low和high一定是相等的a[low] = val; return high; //high可以改为low, 但不能改为val 也不能改为a[low]  也不能改为a[high]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双边循环法"><a href="#双边循环法" class="headerlink" title="双边循环法"></a>双边循环法</h2><blockquote><p>双边循环法：首先选取基准元素pivot，然后设置两个指针left和right分别指向最左和最右。</p><p>每轮循环从right开始，让指针指向的元素和基准元素进行比较如果大于或等于时就向左移动，如果小于就停止停止移动将两个指针所指向的元素进行互换，然后切换到left指针，如果left指针所指向元素小于或等于基准元素就向右移动，如果大于就停止移动并让两个指针所指向的元素进行互换。反复循环直到两个指针重合时与基准元素互换。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//双边循环法Java代码实现</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 递归结束条件：startIndex大于或等于endIndex时</span><span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&gt;=</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 得到基准元素位置</span><span class="token keyword">int</span> pivotIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据基准元素，分成两部分进行递归排序</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> pivotIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivotIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/** * 分治（双边循环法） * @param arr 待交换的数组 * @param startIndex 起始下标 * @param endIndex 结束下标 */</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span> <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> left <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> <span class="token keyword">int</span> right <span class="token operator">=</span> endIndex<span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span> left <span class="token operator">!=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//控制right 指针比较并左移</span> <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span><span class="token punctuation">{</span> right<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//控制left指针比较并右移</span> <span class="token keyword">while</span><span class="token punctuation">(</span> left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> left<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//交换left和right 指针所指向的元素</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> p <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment">//pivot 和指针重合点交换</span> arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h2><blockquote><p>单边循环法与双边循环法的代码实现简单的多，只需从数组的一边对元素进行遍历和交换。</p><p>首先也是选取基准元素pivot，然后设置一个mark指针指向数列起始位置，它代表的是小于基准元素的区域边界。</p><p>现在开始从基准元素的下一个位置的元素开始遍历，如果它大于基准元素就继续遍历，如果它小于就将mark指针右移动一位，再让最新遍历到的元素和mark所指向的元素交换位置</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Python写出来的代码好整齐，比Java简洁好多</span><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span>end_index<span class="token punctuation">,</span>array<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 递归结束的条件</span>    <span class="token keyword">if</span> start_index <span class="token operator">&gt;=</span> end_index<span class="token punctuation">:</span>        <span class="token keyword">return</span>     <span class="token comment"># 基准元素的位置</span>    pivot_index <span class="token operator">=</span>partion<span class="token punctuation">(</span>start_index<span class="token punctuation">,</span>end_index<span class="token punctuation">,</span>array<span class="token punctuation">)</span>    <span class="token comment"># 根据基准元素分两部分递归排序</span>    quick_sort<span class="token punctuation">(</span>start_index<span class="token punctuation">,</span> pivot_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span>    quick_sort<span class="token punctuation">(</span>start_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end_index<span class="token punctuation">,</span>array<span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">partion</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span>end_index<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 取第一个位置的元素作为基准元素，也可以随机选择</span>    pivot <span class="token operator">=</span> array<span class="token punctuation">[</span>start_index<span class="token punctuation">]</span>    mark <span class="token operator">=</span> start_index    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>start_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>                mark <span class="token operator">+=</span><span class="token number">1</span>                p <span class="token operator">=</span> array<span class="token punctuation">[</span>mark<span class="token punctuation">]</span>                array<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p    array<span class="token punctuation">[</span>start_index<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>mark<span class="token punctuation">]</span>    array<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">=</span> pivot    <span class="token keyword">return</span> markmy_array <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>quick_sort<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> my_array<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非递归实现快速排序"><a href="#非递归实现快速排序" class="headerlink" title="非递归实现快速排序"></a>非递归实现快速排序</h2><blockquote><p>快速排序也可以使用非递归的方法实现，绝大多数的递归逻辑都可以使用栈来实现，递归中代码一层一层的调用本身就使用了一个方法调用栈，每次进入一个新方法就是入栈，每次有方法返回就是出栈。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 递归结束条件：startIndex大于或等于endIndex时</span><span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&gt;=</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 得到基准元素位置</span><span class="token keyword">int</span> pivotIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据基准元素，分成两部分进行递归排序</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> pivotIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivotIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*** 分治（双边循环法）* @param arr 待交换的数组* @param startIndex 起始下标* @param endIndex 结束下标*/</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span><span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> left <span class="token operator">=</span> startIndex<span class="token punctuation">;</span><span class="token keyword">int</span> right <span class="token operator">=</span> endIndex<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> left <span class="token operator">!=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//控制right 指针比较并左移</span><span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>right<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//控制left指针比较并右移</span><span class="token keyword">while</span><span class="token punctuation">(</span> left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>left<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//交换left和right 指针所指向的元素</span><span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> p <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//pivot 和指针重合点交换</span>arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和刚才的递归实现相比，非递归方式代码的变动只发生在quickSort方法 中。该方法引入了一个存储Map类型元素的栈，用于存储每一次交换时 的起始下标和结束下标。 每一次循环，都会让栈顶元素出栈，通过partition方法进行分治，并且 按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。</p><blockquote><p>数据结构研究的是数据的存储和数据的操作的一门课；</p><p>数据的存储分两部分</p><ul><li>​    个体的存储；</li><li>​    个体关系的存储；</li></ul><p>从某个角度而言，数据的存储最核心的就是个体关系的存储，个体的存储可以忽略不计，就像二叉树里不考虑节点的数据类型一样</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>​        在郝斌老师视频的帮助下，我从最开始的学习C语言入门，到后来的数据结构入门，感谢郝斌老师的视频，感谢UP主蠢杠杠！数据库和Java我看的其他课程哈^_^。</p><p>​        虽然现在已经是2021年了，但是经典的基础知识点永不过时！我在看数据结构的时候，中间曾有数次间断学习，也曾看过其他的很多有关的课程，但是郝斌老师的课易于理解不像其他课程一样理论知识点繁多，用来入门非常合适。当然，技术飞快更迭有一小部分变化或者说有了更多更新的内容，建议还是要去完善数据结构的知识树，郝斌老师的数据结构课只是给了我们一个不太完整的树干，基础已经打好了，但是需要我们自己去开枝散叶！</p><p>​        感觉可能是视频不全的原因吧，而且最开始由于对指针的理解问题，其实最开始的部分视频不是讲的数据结构，而是带我们复习学习的C语言的指针。对于链表来说，C语言的指针的理解非常重要，我记得最开始我真的看的很头疼，好多次看着看着睡了，好在后来通过线下课程我把C语言又强化了一遍，之后敲起链表来才算得心应手一点。因为我之后看了其他的很多课程，中间由于一些原因又学了Python等内容，觉得对数据结构内容基本了解，就没坚持看了，而现在我看完郝斌老师的课程后我发现郝斌老师的有些讲解让我打开了新世界的大门感觉，对于一个知识，不是说你知道就等于了解了，我之前自已为是的了解其实只是浅显的知道，现在才是理解，而接下来，我还需要不断的实践去深入了解，就像我现在还没法独立的把有些代码手撕出来。我还记得，有次是老师的电脑丢了还是什么，有些视频都是老师熬着夜在家里录得，泪目了！</p><p>​        直到现在，我还是没找好未来的发展方向，在焦虑思考过后也没能找到答案，但是不管未来是怎样，脚踏实地的走好每一步总是没错的，活在当下吧！之后打算把之前学习的内容陆续整理其实也是再学习，上传到博客上，中间也会有新学习的内容上传，希望能坚持吧！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归与树</title>
      <link href="/2021/12/01/shu-ju-jie-gou-yu-suan-fa/di-gui-yu-shu/"/>
      <url>/2021/12/01/shu-ju-jie-gou-yu-suan-fa/di-gui-yu-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="递归（recursion）"><a href="#递归（recursion）" class="headerlink" title="递归（recursion）"></a>递归（recursion）</h1><h2 id="递归的定义："><a href="#递归的定义：" class="headerlink" title="递归的定义："></a>递归的定义：</h2><blockquote><p>递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。</p></blockquote><p>递归的思想是<strong>把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止</strong>。</p><h2 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h2><p>为了保障函数正常运行，必须避免出现<strong>死循环</strong>！所以函数中必须包括如下属性</p><ul><li>必须有一个明确的中止条件</li><li>该函数处理的数据规模必须递减</li><li>可将所有其他情况拆分到基本案例</li></ul><h2 id="特点和应用"><a href="#特点和应用" class="headerlink" title="特点和应用"></a>特点和应用</h2><ul><li>代码量相较其他解法来说少，而且容易理解。可以用有限的语句描述对象的无限集合</li><li>递归调用程序需要维护调用栈，而栈具有后进先出的特征，因此递归程序适合满足取反类需求，比如字符串取反，链表取反等相关有趣的算法问题。</li><li>具有递推关系的问题基本都可以通过递归求解。比如杨辉三角，阶乘计算等</li></ul><p>栈和队列是线性结构的具体实现，是一种特殊的线性结构</p><p>内存是线性一维的，但现实中的事物是复杂的，所以要研究数据结构即如何将现实中的复杂数据高效的用线性一维的计算机存储空间进行存储。</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树定义"><a href="#树定义" class="headerlink" title="树定义"></a>树定义</h2><ol><li>有且只有一个称为根的节点</li><li>有若干个互不相交的子树，子树本身也是一棵树</li></ol><p>专业术语：</p><ul><li>​    非终端节点：实际就是非叶子节点</li><li>​    度：子节点的个数称为度</li><li>​    深度：树的层数</li></ul><h2 id="树分类"><a href="#树分类" class="headerlink" title="树分类"></a>树分类</h2><p>一般树：任意一个节点的子节点的个数不受限制</p><p>二叉树：任意一个节点的子节点的个数最多两个，且子节点位置不能更改</p><ul><li>一般二叉树：</li><li>满二叉树：在不增加树的层数的前提下，无法再多添加一个节点的二叉树就是满二叉树，即每一层节点都是最大节点树</li><li>完全二叉树：如果只是删除了满二叉树最底层最右边的连续的若干节点，这样形成的二叉树就是完全二叉树</li></ul><p>森林：n个互不相交的树的集合</p><h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><p>计算中硬件的存储方式是线性一维的就像一条梯子里一个一个格子一样，而现实中的问题往往是复杂多变多维的。</p><p>如何用内存保存现实中的事物？用人为定义的一种规则将其转化到计算机中保存并能还原。</p><p>非线性的树转化为一维线性的硬件去存储，按照前中后的规则存储</p><p>为什么要把树转化成完全二叉树存储？</p><p>因为不能只存有效节点，如果只存有效节点的话，根据一维的有效节点的顺序无法推算出树本来的样子。</p><p>存垃圾节点很浪费空间为啥还要用完全二叉树存储？</p><ol><li>已知任何一个节点，可以知道它的父节点、子节点、有没有子节点【查找某个节点的父、子节点的速度很快】</li><li>知道节点的个数就能知道在第几层</li></ol><p>有三种不同规则（前序，中序，后序）可以将树转化成一维的结构。</p><p>一般树转化为满二叉树，在把垃圾节点删掉就是完全二叉树，在存储中一般用完全二叉树存储，完全二叉树是重点。</p><p>二叉树的存储：</p><ul><li><p>连续存储【完全二叉树】：</p><p>优点：查找某个节点的父节点和子节点快，查找效率高</p><p>缺点：耗内存高</p></li><li><p>链式存储【链表实现】：</p></li></ul><p>一般树的存储：</p><ul><li>双亲表示法：每个节点的指针域存储父节点的地址【找父节点简单，找子节点难】</li><li>孩子表示法：每个节点的指针域依次存储该节点的所有子节点【找子节点方便，找父节点难】</li><li>双亲孩子表示法：指针域分两个一个存父节点的位置，一个存所有子节点的位置【求父求子都方便】</li><li>二叉树表示法：保证满足任意一个节点的左指针域指向第一个孩子，右指针域指向兄弟【把普通树转化为二叉树】</li></ul><p>森林的存储：</p><p>类似把一般树转化为二叉树，把森林转化为二叉树</p><h2 id="树的操作"><a href="#树的操作" class="headerlink" title="树的操作"></a>树的操作</h2><p>​    树的遍历【递归】</p><ul><li><p>先序遍历【最先访问根节点】</p><p>先遍历根节点，再访问左子树，最后右子树；</p></li><li><p>中序遍历【中间访问根节点】</p><p>先遍历左子树，再访问根节点，最后右子树；</p></li><li><p>后序遍历【最后访问根节点】</p><p>先遍历左子树，再访问右子树，最后根节点；</p></li></ul><p>​    已知两种遍历序列求原始二叉树</p><p>​        通过先序、中序或中序、后序能还原出原始二叉树，但是通过先序、后序是无法还原出原始二叉树的。</p><p>例子：</p><p> 先序ABDGHCEFI、中序GDHBAECIF。求后序得：GHDBEIFCA</p><p> 中序BDCEAFHG、后序DECBHGFA。求先序得：ABCDEFGH</p><ul><li>【知先与中，用先确定”根“，中确定左右子树】</li><li>【知中与后，用后确定“根”，中确定左右子树】</li><li>【先与后都是确定“根”的，所以知道先后无法求中】</li></ul><p>树的应用</p><ul><li>树是数据库中数据组织的一种重要形式；</li><li>操作系统子父进程的关系本身就是一颗树；</li><li>面向对象语言中类的继承关系本身就是一棵树</li><li>哈夫曼树</li></ul><h2 id="二叉树代码实现："><a href="#二叉树代码实现：" class="headerlink" title="二叉树代码实现："></a><strong>二叉树代码实现：</strong></h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;struct BTNode{    int data;    struct BTNode * pLchild;//p为指针，L是左，R是右；    struct BTNode * pRchild;};struct BTNode * CreateBTree(void){    struct BTNode * pA = (struct BTNode *)malloc(sizeof(struct BTNode));    struct BTNode * pB = (struct BTNode *)malloc(sizeof(struct BTNode));    struct BTNode * pC = (struct BTNode *)malloc(sizeof(struct BTNode));        pA-&gt;data = 'A';    pB-&gt;data = 'B';    pC-&gt;data = 'C';        pA-&gt;pLchild = pB;    pA-&gt;pRchild = pC;    pB-&gt;pLchild = pB-&gt;pRchild = NULL; pC-&gt;pLchild = pC-&gt;pRchild = NULL;        return pA;}void PreTraverseBTree(struct BTNode * pT){    if(pT)//NULL可以当false用或者pT！=NULL；     {         printf("%c\n",pT-&gt;data);          if(NULL != pT-&gt;pLchild)        {PreTraverseBTree(pT-&gt;pLchild);}        if(NULL != pT-&gt;pRchild)        {        PreTraverseBTree(pT-&gt;pRchild);    }}    }void INTraverseBTree(struct BTNode *pT){      if(pT)//NULL可以当false用或者pT！=NULL；     {                if(NULL != pT-&gt;pLchild)        {INTraverseBTree(pT-&gt;pLchild);}printf("%c\n",pT-&gt;data);        if(NULL != pT-&gt;pRchild)        {        INTraverseBTree(pT-&gt;pRchild);    }}    }void PostTraverseBTree(struct BTNode *pT){       if(pT)//NULL可以当false用或者pT！=NULL；     {                if(NULL != pT-&gt;pLchild)        {INTraverseBTree(pT-&gt;pLchild);}        if(NULL != pT-&gt;pRchild)        {        INTraverseBTree(pT-&gt;pRchild);    }    printf("%c\n",pT-&gt;data);}    }int main(void){    BTNode * pT = CreateBTree();//创建树    PreTraverseBTree(pT);//先序    printf("-------\n");    INTraverseBTree(pT);//中序    printf("-------\n");    PostTraverseBTree(pT);//后序    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="树的理论解释"><a href="#树的理论解释" class="headerlink" title="树的理论解释"></a>树的理论解释</h1><p>什么是树？</p><p>在实际场景中，数据除了线性结构以外还存在非线性结构，树就是典型的非线性结构，比如人的家谱，书的目录等它们就像树的枝干和根一样。</p><p>在数据结构中，树的定义如下。 树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一 个非空树中，有如下特点。 </p><ul><li>有且仅有一个特定的称为根的节点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。</li></ul><p>二叉树：</p><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树 的每个节点最多有2个孩子节点 。注意，这里是最多有2个，也可能只 有1个，或者没有孩子节点。</p><p>二叉树节点的两个孩子节点，一个被称为左孩子（left child） ，一个被 称为右孩子（right child） 。这两个孩子节点的顺序是固定的，就像人 的左手就是左手，右手就是右手，不能够颠倒或混淆。 此外，二叉树还有两种特殊形式，一个叫作满二叉树 ，另一个叫作完 全二叉树 。 什么是满二叉树呢？ 一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在 同一层级上，那么这个树就是满二叉树。</p><p>简单点说，满二叉树的每一个分支都是满的。 什么又是完全二叉树呢？完全二叉树的定义很有意思。 对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1 到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。</p><p>数据结构可以划分为物理结构和逻辑结构。二叉树属于逻辑结构，它可以通过多种物 理结构来表达。 二叉树可以用哪些物理存储结构来表达呢？ </p><ol><li><p>链式存储结构。</p><p>链表是一对一的存储方式，每一个链表节点拥有data 变量和一个指向下一节点的next指针。 而二叉树稍微复杂一些，一个节点最多可以指向左右两个孩子节点，所以二叉树的每一个节点包含3部分。 </p><blockquote><p>存储数据的data变量 </p><p>指向左孩子的left指针 </p><p>指向右孩子的right指针 </p></blockquote></li><li><p>数组。</p></li></ol><blockquote><p>按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。 </p></blockquote><p>为什么空出相应的位置呢？</p><p>因为这样可以更方便地在数组中定位二叉树的孩子节点和父节点。 假设一个父节点的下标是parent，那么它的左孩子节点下标就 是2×parent + 1 ；右孩子节点下标就是2×parent + 2 。 反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标就是（leftChild-1）/ 2 。假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标可以直接通过计算得出。 节点2的下标 = (3-1)/2 = 1 显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。 </p><p>什么样的二叉树最适合用数组表示呢？ 二叉堆一种特殊的完全二叉树，就是用数组来存储的</p><p>二叉树都有哪些遍历方式呢？</p><p> 从节点之间位置关系的角度来看，二叉树的遍历分为4种。</p><ul><li>前序遍历。</li><li>中序遍历。</li><li>后序遍历。 </li><li>层序遍历。 </li></ul><p>从更宏观的角度来看，二叉树的遍历归结为两大类。 </p><ul><li><p>深度优先遍历 （前序遍历、中序遍历、后序遍历）。 </p></li><li><p>广度优先遍历 （层序遍历）。</p></li></ul><h1 id="补充：树的层序遍历"><a href="#补充：树的层序遍历" class="headerlink" title="补充：树的层序遍历"></a>补充：树的层序遍历</h1><p>层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。由于二叉树同一层次的节点之间是没有直接关联的，所以需要借助队列这种数据结构来辅助工作。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/*** 二叉树层序遍历* @param root 二叉树根节点*/public static void levelOrderTraversal(TreeNode root){Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();queue.offer(root);while(!queue.isEmpty()){TreeNode node = queue.poll(); System.out.println(node.data); if(node.leftChild != null){ queue.offer(node.leftChild);} if(node.rightChild != null){ queue.offer(node.rightChild); }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何判断一个链表是否有环</title>
      <link href="/2021/11/29/shu-ju-jie-gou-yu-suan-fa/ru-he-pan-duan-yi-ge-lian-biao-shi-fou-you-huan/"/>
      <url>/2021/11/29/shu-ju-jie-gou-yu-suan-fa/ru-he-pan-duan-yi-ge-lian-biao-shi-fou-you-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="如何判读一个链表是不是有环链表？"><a href="#如何判读一个链表是不是有环链表？" class="headerlink" title="如何判读一个链表是不是有环链表？"></a>如何判读一个链表是不是有环链表？</h2><h3 id="暴力菜鸟版1"><a href="#暴力菜鸟版1" class="headerlink" title="暴力菜鸟版1"></a>暴力菜鸟版1</h3><p>直接遍历这个链表，每进一个新结点就把这个节点和先前已经遍历的节点进行比较，如果新节点和之前遍历过得节点相同，那说明为有环节点，如果没有那么继续，直到尾节点也没有重复，那说明不是有环链表。</p><ul><li>假设链表的节点数量为n，则该解法的时间复杂度为O(n 2 ) 。</li><li>由于并没 有创建额外的存储空间，所以空间复杂度为O(1) 。</li></ul><h3 id="暴力菜鸟版2"><a href="#暴力菜鸟版2" class="headerlink" title="暴力菜鸟版2"></a>暴力菜鸟版2</h3><p>首先创建一个以节点ID为Key的HashSet集合，用来存储曾经遍历过的节点。然后同样从头节点开始，依次遍历单链表中的每一个节点。每遍历 一个新节点，都用新节点和HashSet集合中存储的节点进行比较，如果 发现HashSet中存在与之相同的节点ID，则说明链表有环，如果HashSet 中不存在与新节点相同的节点ID，就把这个新节点ID存入HashSet中， 之后进入下一节点，继续重复刚才的操作。</p><p>这个方法在流程上和方法1类似，本质的区别是使用了HashSet作为额外 的缓存。 </p><ul><li>假设链表的节点数量为n，则该解法的时间复杂度是O(n) 。</li><li>由于使用了 额外的存储空间，所以算法的空间复杂度同样是O(n) 。</li></ul><h3 id="进阶高手版"><a href="#进阶高手版" class="headerlink" title="进阶高手版"></a>进阶高手版</h3><p>首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时 指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1 每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个 指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环</p><p>如果是有环链表就像是在环形跑道中，一个速度快一个速度慢，总会追上得，类似追及问题。</p><ul><li>假设链表的节点数量为n，则该算法的时间复杂度为O(n)。</li><li>除两个指针外，没有使用任何额外的存储空间，所以空间复杂度是O(1)。</li></ul><p>代码实现：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static boolean isCycle(Node head){Node p1 = head;Node p2 = head;while (p2!Null &amp;&amp; p2.next != NULL) {p1 = p1.next;p2 = p2.next;if (p1 = p2) {return true;}}return false;}private static class Node {int data;Node next;Node(int data) {this.data = data;}};public static void main(String[] args) throws Exception {Node node1 = new Node(5);Node node2 = new Node(3);Node node3 = new Node(7);Node node4 = new Node(2);Node node5 = new Node(6);node1.next = node2;node2.next = node3;node3.next = node4;node4.next = node5;node5.next = node2;System.out.println(isCycle(node1));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Python版代码实现class Node:    def _init_(self,data):        self.data = data        self.next = nonedef is_cycle(head):    p1 = headp2 = head    while p2 is not None and p2,next is not None:        p1 = p1.next;p2 = p2.next.next;if p1 = p2:return true;return Falsenode1 = new Node(5);node2 = new Node(3);node3 = new Node(7);node4 = new Node(2);node5 = new Node(6);node1.next = node2;node2.next = node3;node3.next = node4;node4.next = node5;node5.next = node2;print(is_cycle(nodel))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展问题1：如果链表有环，如何求出环的长度？"><a href="#扩展问题1：如果链表有环，如何求出环的长度？" class="headerlink" title="扩展问题1：如果链表有环，如何求出环的长度？"></a>扩展问题1：如果链表有环，如何求出环的长度？</h3><p>当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时， 统计出来的前进次数就是环长。 因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两 个指针再次相遇时，p2比p1多走了整整1圈。 </p><p>因此，环长 = 每一次速度差 × 前进次数 = 前进次数。</p><h3 id="扩展问题2：-如果链表有环，如何求出入环节点？"><a href="#扩展问题2：-如果链表有环，如何求出入环节点？" class="headerlink" title="扩展问题2： 如果链表有环，如何求出入环节点？"></a>扩展问题2： 如果链表有环，如何求出入环节点？</h3><p>这个问题难一点点，但是耐心一点相信你能看懂的！</p><p><img src="/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/image_loop.png"></p><p>假设从链表头节点到入环点 的距离是D，</p><p>从入环点到两个指针首次相遇点的距离是S1 ，</p><p>从首次相遇点回到入环点的距离是S2。</p><p>那么，当两个指针首次相遇时，各自所走的距离是多少呢？ </p><p>指针p1一次只走1步，所走的距离是D+S 1。</p><p>指针p2一次走2步，多走了n(n&gt;=1)整圈，所走的距离是D+S1 +n(S1 +S1 )。 </p><p>由于p2的速度是p1的2倍，所以所走距离也是p1的2倍，</p><p>因此： 2(D+S1 ) = D+S1+n(S1+S2 ) 等式</p><p>经过整理得出： D = (n-1)(S1+S2 )+S2 也就是说，从链表头结点到入环点的距离，等于从首次相遇点绕环n-1圈再回到入环点的距离。 </p><p>这样一来，只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。</p><p>本文来源自读书笔记：小灰的算法之旅,侵权必删。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小栈的实现</title>
      <link href="/2021/11/29/shu-ju-jie-gou-yu-suan-fa/zui-xiao-zhan-de-shi-xian/"/>
      <url>/2021/11/29/shu-ju-jie-gou-yu-suan-fa/zui-xiao-zhan-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="最小栈的实现"><a href="#最小栈的实现" class="headerlink" title="最小栈的实现"></a>最小栈的实现</h1><p><strong>题目：</strong>实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素 （getMin）3个方法。要保证这3个方法的时间复杂度都是O(1)。</p><p><strong>解题思路：</strong></p><p>step1：设原栈为栈A，辅组栈为B，当第一个元素进栈A时，同时让新元素也进入栈B，这个唯一元素即原栈A的最小值。</p><p>Step2：每当有新元素进入栈A时，如果新元素比栈A小就同时让新元素也进入栈B，此时栈B的栈顶元素同时也是栈A的最小值。</p><p>Step3：每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A当中原本第2小的元素，代替刚才的出栈元素成为栈A的当前最小值。</p><p>Step4：当调用getMin方法时，返回栈B的栈顶所存储的值，这也是栈A的最 小值。</p><p>这个解法中进栈、出栈、取最小值的时间复杂度都是O(1)，最坏 情况空间复杂度是O(n)。</p><p>代码实现：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Stack&lt;Integer&gt; mainStack = new Stack&lt;Integer&gt;();private Stack&lt;Integer&gt; minStack = new Stack&lt;Integer&gt;();/*** 入栈操作* @param element 入栈的元素*/public void push(int element) {mainStack.push(element);//如果辅助栈为空，或者新元素小于或等于辅助栈栈顶，则将新元素压入辅助栈if (minStack.empty() || element &lt;= minStack.peek()) {minStack.push(element);}}/*** 出栈操作*/public Integer pop() {//如果出栈元素和辅助栈栈顶元素值相等，辅助栈出栈 if (mainStack.peek().equals(minStack.peek())) {minStack.pop(); }return mainStack.pop();}/*** 获取栈的最小元素*/public int getMin() throws Exception { if (mainStack.empty()) { throw new Exception("stack is empty"); } return minStack.peek(); }public static void main(String[] args) throws Exception {MinStack stack = new MinStack();stack.push(4);stack.push(9);stack.push(7);stack.push(3);stack.push(8);stack.push(5);System.out.println(stack.getMin());stack.pop();stack.pop();stack.pop();System.out.println(stack.getMin());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试的方法和技术相关</title>
      <link href="/2021/11/22/ruan-jian-ce-shi/ruan-jian-ce-shi-de-fang-fa-he-ji-zhu-xiang-guan/"/>
      <url>/2021/11/22/ruan-jian-ce-shi/ruan-jian-ce-shi-de-fang-fa-he-ji-zhu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试的方法"><a href="#软件测试的方法" class="headerlink" title="软件测试的方法"></a>软件测试的方法</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>软件测试的一些技术和分类划分了解，虽然已经入土了，但是花时间了解的东西一起放出来把，哈哈！</p><h2 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h2><p>功能测试 —测试人员用鼠标去手动测试 （测试GUI）,点点点测试</p><p>自动化测试 —用程序测试程序 （测试API），解放双手</p><p>性能测试 —定位系统瓶颈，保证系统良好性能与稳定性</p><p>黑盒测试 —测试应用程序的功能，验证结果是否正确</p><p>白盒测试 —测试程序内部结构，以编程语言角度设计测试案例</p><h2 id="软件测试功能分类"><a href="#软件测试功能分类" class="headerlink" title="软件测试功能分类"></a>软件测试功能分类</h2><p>按测试阶段划分</p><ul><li>单元测试 Unit Testing，对每一个代码函数测试，属于白盒测试范畴，主要检查单元内部数据结构、逻辑控制、异常处理等</li><li>集成测试 Integration Testing，对代码组成的模块进行测试，属于灰盒测试范畴，检查模块之间的数据传输</li><li>系统测试 System Testing，针对每一个功能需求，完整的设计测试环境，指派测试人员执行，属于黑盒测试范畴，检查整个软件是否满足了需求</li></ul><h3 id="α、β测试"><a href="#α、β测试" class="headerlink" title="α、β测试"></a>α、β测试</h3><p>α测试活动好比游戏的删档内测</p><ul><li>由企业内部员工在模拟真实环境下进行的测试活动，进行结果反馈<ul><li>员工在开发人员的接入下，通过指导进行软件使用，且随时记录下使用过程中的错误</li></ul></li><li>由真实用户在软件内测版本，开发版本环境下进行的产品体验/测试活动，进行结果反馈</li><li>α测试的目的是评价软件产品的FLURPS(即功能、局域化、可用性、可靠性、性能和支持)。</li><li>α测试即为非正式验收测试，尤其注重产品的界面和特色，</li></ul><p>β测试好比游戏的不删档公测</p><ul><li>由多个用户在实际操作环境下进行产品功能测试，如不同的手机型号，平台，网络环境等</li><li>β测试不受开发者控制，自主开展测试活动，然后进行结果反馈</li></ul><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><ul><li><p>黑盒称为功能测试，一是按顺序检测程序每个功能，二是按功能模块优先级测试。</p></li><li><p>对软件的界面和功能进行测试，只考虑其整体特性，不考虑其内部实现</p></li><li><p>需要根据说明书、用户手册进行功能测试</p></li><li><p>如电视遥控器，就是一个标准的黑盒测试，我们不管是液晶的还是其他方式，只需要查看遥控器是否能控制空调</p></li><li><p>要求多组数据，多次测试才能得到准确的报告黑盒测试类型</p></li><li><p>功能性测试，网站顺序使用的功能，手机使用功能，显示器是否正常显示…</p></li><li><p>容量测试，海量数据的处理，如1亿人用微信，1亿人用支付宝，这个数值容量</p></li><li><p>负载测试，系统在短时间内处理海量数据时，系统的健康状况指标</p></li><li><p>恢复性测试，小米手机秒杀活动太过热火，网站挂了，不该影响用户数据</p></li></ul><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>白盒测试就打开了盒子，可以看到软件的内部代码</p><p>对比黑盒测试，白盒测试更严谨，对软件的源码和架构进行测试。</p><p>需要软件源代码，流程图等设计文档。</p><p>依据被测软件分析程序内部构造，并且根据内部结构设计测试用例，针对内部控制流程进行测试。</p><p>白盒测试是基于程序结构的逻辑驱动测试。</p><p>白盒测试的方法</p><ul><li><p>静态分析：控制流分析，数据流分析，信息流分析</p></li><li><p>动态分析：逻辑覆盖测试（分支测试、路径测试）、程序插装</p></li><li><p>语句覆盖</p></li><li><p>判定覆盖</p></li><li><p>条件覆盖</p></li><li><p>路径覆盖</p></li></ul><p>逻辑覆盖率的统计通过程序插装可以体现程序插装</p><ul><li>调试代码时，往往会在程序中添加<code>print()</code>语句，能够很方便的打印出我们想要的信息，进一步了解程序执行的一些动态信息，比如程序执行顺序，计算后的变量的具体指等。</li><li>程序插装技术能够按照用户的要求，获取程序部分信息，是测试工作的有效手段。</li></ul><ol><li><code>黑盒测试的优点有:</code></li><li><code>1. 比较简单，不需要了解程序内部的代码及实现;</code></li><li><code>2. 与软件的内部实现无关;</code></li><li><code>3. 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题;</code></li><li><code>4. 基于软件开发文档，所以也能知道软件实现了文档中的哪些功能;</code></li><li><code>5. 在做软件自动化测试时较为方便。</code></li><li>``</li><li><code>黑盒测试的缺点有:</code></li><li><code>1. 没有清晰的测试规格说明，测试用例难以设计</code></li><li><code>2. 自动化测试的复用性较低。</code></li><li><code>3. 无法控制程序内部路径，可能缺少较多测试点</code></li><li>``</li><li><code>白盒测试的优点有:</code></li><li><code>1. 帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐藏的问题。</code></li><li>``</li><li><code>白盒测试的缺点有:</code></li><li><code>1. 程序运行会有很多不同的路径，不可能测试所有的运行路径;测试基于代码，只能测试开发人员做的对不</code></li><li><code>对，而不能知道设计的正确与否，可能会漏掉一些功能需求;系统庞大时，测试开销会非常大。</code></li></ol><h2 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h2><p>介于白盒与黑盒之间，针对被测对象信息的不同，采用不同的测试方法。</p><ul><li>检验被测对象整体特性信息，采用黑盒测试</li><li>检验被测对象内部实现，采用白盒测试</li><li>既要观察被测对象整体信息，又要观察内部具体信息，信息占比不同，这就是所谓灰盒测试。</li></ul><h2 id="软件测试文档"><a href="#软件测试文档" class="headerlink" title="软件测试文档"></a>软件测试文档</h2><p>软件研发如同工厂生产，整个过程会有产品输出，输出的产品有两类</p><ul><li><p>编译好的代码程序，如QQ.exe</p></li><li><p>用户使用手册，QQ使用手册</p></li><li><p>源代码,QQ源代码</p></li><li><p>需求分析：软件测试依据</p></li><li><p>概要设计：根据需求分析的内容，进行方案设计，明确是否覆盖到软件的需求</p></li><li><p>详细设计：包含方案、策略、架构、体系、接口名、接口文档、数据结构算法，保证开发过程细致</p></li><li><p>测试设计：测试需要进行哪些内容，包含哪些功能点，是否会影响其他功能，例如第三方支付页面跳转</p></li><li><p>测试用例：用例是进行测试的依据，测试的规范条文</p></li><li><p>测试报告：测试成功数量、失败数量、测试是否通过，允许产品上线等</p></li></ul><h2 id="动态测试与静态测试"><a href="#动态测试与静态测试" class="headerlink" title="动态测试与静态测试"></a>动态测试与静态测试</h2><p>静态测试：不运行被测试的软件系统，采用例如代码阅读、文档评审、代码分析等方式进行软件测试。</p><p>动态测试：按照预先规划好的测试数据与流程执行被测软件系统。</p><h3 id="静态分析技术"><a href="#静态分析技术" class="headerlink" title="静态分析技术"></a>静态分析技术</h3><p>定义：静态分析是不执行程序而分析程序的技术</p><p>功能：检查软件功能与需求是否一致，没有明显缺陷与歧义</p><p>测试点：</p><ul><li>程序代码语法上是否一致性与完整性</li><li>文档描述是否规范、精准、便于查阅</li><li>程序与文档之间描述的一致性</li></ul><h3 id="动态分析技术"><a href="#动态分析技术" class="headerlink" title="动态分析技术"></a>动态分析技术</h3><p>对软件系统进行数据驱动运行，与期望结果进行对比检查的过程。</p><ul><li>脚本录制工具，进行反复测试，回归测试，如Robot、QTP、Selenium工具</li><li>性能测试工具，LoadRunner、Robot等</li></ul><p>文章学习来源：<a href="https://pythonav.com/wiki/detail/8/71/">https://pythonav.com/wiki/detail/8/71/</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试方向探索</title>
      <link href="/2021/11/22/ruan-jian-ce-shi/ruan-jian-ce-shi-fang-xiang-tan-suo/"/>
      <url>/2021/11/22/ruan-jian-ce-shi/ruan-jian-ce-shi-fang-xiang-tan-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在20世纪50年代，英国计算机科学家图灵就已经提出了程序测试的定义，测试是验证程序正确性的一种实验形式。可人们一直到60-70年代软件危机出现后才意识到测试的意义。这使我想起了改编自安德鲁·霍奇斯编著的传记《艾伦·图灵传》的电影–《模仿游戏》。毫无疑问，图灵是一个伟大的科学家！</p><blockquote><p>​    有时候，正是那些人们认为的无用之人成就了无人所成之事！    –《艾伦·图灵传》</p></blockquote><p>说到软件测试就不得不提到BUG，世界上第一个软件bug由Grace Murray Hopper定义，她是历史上最早一批程序员，而且还是个女程序员，服役于美国海军，官至准将。</p><p>自我接触计算机专业以来，到现在为止已经将近一年多了还没有找到属于自己的方向，今天就来了解一下软件测试工程师，看看是否是我感兴趣的发展方向。</p><h2 id="什么是软件测试？"><a href="#什么是软件测试？" class="headerlink" title="什么是软件测试？"></a>什么是软件测试？</h2><p>软件测试是什么？就是一场本该在客户面前发生的灾难，提前被你的专业技术拦截拯救，避免了被客户卸载的命运，为企业创造商业价值。</p><p>测试让一场本该在用户面前发生的软件bug灾难，提前在自己眼前发生</p><p>仿佛有了预知未来的能力，如同一个救世主</p><p>拯救了一个软件bug，也拯救了这个软件，避免了被卸载的命运。</p><p>测试拯救了程序员兄弟被喷的命运</p><p>测试改变了用户卸载bug产品的命运</p><p>测试挽救了老板的金钱道路</p><p>做好幕后英雄，这是就是测试的魅力！</p><p>软件中的Bug非常令人讨厌。但同时有缺陷的软件还有可能造成重大甚至致命的事故。下面是一些非常有名的软件事故：</p><p>1、1962年，水手号火箭的致命BUG。<br>经济损失：1850万美元<br>1962年，携带空间探测器的水手1号火箭前往金星，在起飞后不久就偏离了预定航线。任务控制在起飞293秒后摧毁了火箭。事故的起因就在于一名程序员把一条手写的公式抄写为错误的计算机代码。从而将火箭引导偏离了航向。</p><p>2、1979年，新西兰航空公司的一架客机因计算机控制的自动飞行系统发生错乱，撞在了阿尔卑斯山，导致257名乘客遇难。</p><p>3、几乎引发的第三次世界大战. 1983年, 苏联导弹预警系统错误地报告遭到美国发射的5枚导弹攻击. 但幸运的是,当时的负责人认为如果美国真的要攻击的话, 发射的决不只是5枚导弹. 最终没有酿成大灾难。</p><p>4、2012年，苹果ios 6系统首次使用地图服务，由于诸多定位出现错误，引发大批量用户投诉，48小时内有1000万个用户投诉Google地图。</p><p>5、拼多多近期出现一个重大bug，程序员误改了代码，原本100元的中国移动充值卡，一分钱就可以购买，很短的时间内就损失了大量金额财产，这已经触犯了刑事责任。</p><h2 id="软件测试的修炼之路"><a href="#软件测试的修炼之路" class="headerlink" title="软件测试的修炼之路"></a>软件测试的修炼之路</h2><p>基础软件测试工程师(6-10k)</p><ol><li>负责生命周期各阶段对应测试；</li><li>独立设计和执行测试方案和测试用例；</li><li>进行设备搭建和维护测试环境；</li><li>协助开发人员快速重现和解决产品BUG；</li><li>负责测试文档的撰写；</li></ol><p>自动化测试工程师(10-15k)<br>1、对持续集成、持续交付、自动化测试等技术进行研究、测试实践、手册撰写；<br>2、对核心技术产品进行自动化测试；<br>3、负责与直属领导及其他技术研究员及时交流持续集成、持续交付、自动化测试研究、实践过程中的问题及成果；<br>4、负责根据需求说明、设计文档来分析测试内容、确定测试方法、设计测试用例、编写测试脚本、执行测试，并编写测试报告；<br>5、负责搭建、维护技术研究、测试所需的环境；</p><p>测试开发工程师(15-30k)<br>具备3年以上无线端开发/测试 或者 web产品开发/测试<br>精通自动化测试常用工具（如monkeyrunner，appium,selenium等）<br>掌握PHP/JAVA/C/C++或几种脚本语言如python/shell 等，能熟练编写代码<br>精通软件测试理论和方法，熟悉互联网行业测试环境及相关技术<br>熟悉Linux/Unix操作系统<br>善于学习和运用新知识，具有良好的分析和解决问题能力<br>在web、android、ios,接口等自动化领领域有较深的造诣和见解<br>能够独立使用php/java/python独立进行web开发<br>有相关自动化工具/平台（web/app/api接口/测试相关平台工具）开发经验或者二次开发经验者优先。</p><p><strong>字节跳动测试工程师岗位要求</strong>(20-25k)</p><p>岗位要求（来源：2021.11.22牛客网）</p><ol><li>2022届获得本科及以上学历，计算机相关专业； </li><li>热爱计算机科学和互联网技术，对软件质量保障工作有浓厚兴趣； </li><li>扎实的数据结构和算法基础，熟悉至少一门编程语言，包括但不仅限于：Java、C、C++、Python、Go等；</li><li>优秀的产品意识，对市场上典型App有自己的想法和改进方案； </li><li>快速适应和学习能力，善于发现和定位问题； </li><li>了解常用客户端、服务端开发或测试工具， 如自动化框架、压测工具、大数据处理工具者优先。</li></ol><h2 id="为什么开发人员不做测试？"><a href="#为什么开发人员不做测试？" class="headerlink" title="为什么开发人员不做测试？"></a>为什么开发人员不做测试？</h2><p>开发人员自己做测试的问题所在：<br>人性角度、思维惯性、测试环境复杂度等方面。</p><p>开发人员是创造性思维，面对自己的代码产品无论怎么看都是很完美，恩，真香！</p><p>测试人员是破坏性思维，职责就是各种奇葩角度去发现潜在的问题，并且专职的测试人员通常在以往测试经验中积累大量典型易出错的模式，能够更客观全面的进行测试。</p><p>专职测试人员面对例如Web的GUI测试，基本不是简单的本地浏览器测试，而如大型企业可能会选择Selenium Grid搭建GUI集群进行千百台机器大规模测试，再比如使用Appium+Selenium Grid搭建大规模移动设备测试集群，这些都必须专职人员去完成，开发精力应该是在构建新业务功能，而不是维护测试设施。</p><h2 id="互联网行业的职业"><a href="#互联网行业的职业" class="headerlink" title="互联网行业的职业"></a>互联网行业的职业</h2><p>1.产品经理（Product Manager）</p><p>2.UI设计</p><p>3.前端设计（css/html/js）</p><p>4.后端（python/golang/java）</p><p>5.DBA(mysql/oracle)</p><p>6.运维（linux）</p><p>8.测试（software testing）</p><p>9.算法工程师</p><p>10.大数据工程师（Hadoop）</p><p>11.Android、IOS</p><p>12.架构师</p><p>13.运营</p><p>一个项目组一般由项目经理领导且负责定制项目计划，工作分配，资源配置等。</p><p>项目组人员一般有：</p><ul><li>分析</li><li>设计</li><li>研发</li><li>测试</li><li>运维</li></ul><h3 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h3><p>由于项目、需求的模式不同，软件在生命周期过程中选择的软件开发模型也有所不同。</p><p>早期开发中，软件是边做边改，项目，需求没法管控，软件愈发复杂，开发越难。</p><p>开发模型开始演进，瀑布、原型、螺旋、敏捷等模式出现。</p><p>例：瀑布流开发模型</p><p>瀑布模型如同工地里的建造盖房流程，使用里程碑的方式，严格定义了各开发阶段的输入和输出。如果达不到要求</p><p>的输出，下一阶段的工作就不展开。(银行体系用的最多，一个需求做一年，变化很少。以及印度开发者是瀑布模型的重度使用者)</p><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><p>软件生命周期又称为软件生存周期或系统开发生命周期，是软件的产生直到报废的生命周期。</p><p>整个生命周期包括问题定义与规划、需求分析、系统设计、软件编程、软件测试、软件运维等阶段。</p><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><p>测试是检验软件是否符合用户需求，是否达到软件质量标准，由专门测试部门执行。</p><p>常见测试活动分为：</p><ul><li>单元测试，对每一个代码函数测试</li><li>集成测试，对代码组成的模块进行测试</li><li>系统测试，针对每一个功能需求，完整的设计测试环境，指派测试人员执行</li></ul><h3 id="软件运维"><a href="#软件运维" class="headerlink" title="软件运维"></a>软件运维</h3><p>此阶段软件已经交付上线提供用户使用，进入维护阶段，保证软件系统正常运转，如网站的7*24小时运行，因为软件系统可能出现如下问题：</p><ul><li>由于用户增长造成的性能压力</li><li>服务器出现问题造成系统不可用</li><li>软件系统出现bug</li><li>系统升级出现未知bug</li></ul><p>用户在使用过程中出现问题，反馈给技术支持人员，然后再递交给测试组，由研发组修复。</p><h2 id="软件测试常用名词解释"><a href="#软件测试常用名词解释" class="headerlink" title="软件测试常用名词解释"></a>软件测试常用名词解释</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>也叫做模块测试，进行正确性检查的工作。</p><p>单元测试要从程序内部结构设计测试用例，每个模块可以独立进行测试。</p><p>单元是什么？</p><p>比如Python中的类</p><p>图形化软件的一个窗口，一个功能菜单</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>也叫组装测试，也就是将所有单元测试，进行有序的组合测试</p><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>将整个软件系统看做一个整体进行测试，对功能，性能，硬件，软件所有环节进行测试。</p><p>单元测试目的测试功能是否满足要求。</p><p>系统测试目的测试系统是否满足性能的要求，以及不同的机器系统平台中运行,如一台机器我登陆多个qq，是否可</p><p>以运行，在windows，linux平台运行qq是否正常等方面。</p><h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><p>α测试</p><p>Alpha测试模拟实际操作环境下验收测试，如删档内侧，软件只是初步完成的产品，bug可能较多，不会进行上线</p><p>提供用户访问。</p><p>β测试</p><p>Beta测试系统已经通过内部测试，大部分错误已经修复，即将正式发布，在多个真实环境下发布，如不删档公</p><p>测。</p><p>对比α版本已经有了较大改进，但仍可能存在一些bug，需要大规模测试，例如DNF公司更新一个地图，提供公测</p><p>免费下载，由专业游戏玩家进行游戏结果反馈，开发者啊、再进行修复。</p><p>γ版本</p><p>y版本指的是正式版本，与上线版本几乎无区别。</p><ul><li>c/s：Client客户端、Server服务端，指的是互联网中一台服务器安装服务端软件，每个用户都需要安装客户端软件，例如QQ、微信、游戏。</li><li>b/s：Browser浏览器，Server服务器，不需要安装客户端，只需要有浏览器即可，例如淘宝网、京东网，便于维护与升级。</li><li>bug：指的是软件中不符合用户需求的问题，软件存在的缺陷。</li><li>Testing Environment：软件运行的平台、包括硬件、软件、网络配置。</li><li>Test Case：测试执行之前的详细测试方案，包括测试环境、测试步骤、测试数据、预期结果。<ul><li>测试用例=数据输入+测试结果输出+测试环境配置</li></ul></li><li>Smoke Testing：在软件大规模测试之前，验证基本功能，决定是否有可测性，例如路飞学城的基本登录。</li></ul><h2 id="测试人员的原则"><a href="#测试人员的原则" class="headerlink" title="测试人员的原则"></a>测试人员的原则</h2><ul><li>细心(不要放过任何一个细节)</li><li>信心(对自己的测试结果有信心，防止开发人员说：我的程序不可能出错，你重新再去测！)</li><li>耐心</li><li>团队协作意识</li><li>软件缺陷预防意识</li></ul><p><strong>所有测试动作必须追溯到用户需求</strong></p><p>80%的产品缺陷都是在产品开发过程中的需求定义出现偏差引发的，如果需求得到准确的验证，可以消除80%的返工问题，节省投入成本40%。</p><p><strong>杀虫剂怪事</strong></p><p>软件测试越多，对测试的免疫力也越强，例如开发和测试长时间相处，开发就知道测试人员的套路，也会尽量去避免。</p><p>为了克服杀虫剂怪事，测试人员必须不断编写更新的测试方案，对程序的不同部分进行测试，以找出更多软件测试。</p><h2 id="软件工程标准"><a href="#软件工程标准" class="headerlink" title="软件工程标准"></a>软件工程标准</h2><p>国内通用的软件工程标准主要有<code>ISO9000</code>以及<code>CMM</code></p><p>CMM是专为软件开发组织设计的，侧重于软件开发和改进，在产品的设计和开发的细节做了较多要求。</p><p>CMM(Capability Maturity Model)即软件能力成熟度模型，是向软件组织提供如何增加对其开发和维护软件过程的控制能力，也就是评估软件能力与成熟度的标准。</p><p>ISO9000系列标准的基本思想，主要分为两条：</p><ul><li>控制的思想，对产品形成的全过程-从采购原材料、加工制造到产品销售、售后服务进行控制。</li><li>预防的思想，对产品形成的全过程进行控制以及建立并有效运行自我完善机制达到预防不合格，从根本上减少或消除不合格产品。</li></ul><h2 id="终末：从入门到入土"><a href="#终末：从入门到入土" class="headerlink" title="终末：从入门到入土"></a>终末：从入门到入土</h2><p>测试工程师在我浅显的了解下，看起来日常公作很轻松，工作也不错，而且越是大型的工程所需的测试越发重要，但是我觉得，往后看其实往高处走的测试最终还是要学习开发，测试帮研发检查问题，避免上线以后可能的错误，那测试本身其实还是要去了解开发。换句话来说，最终，这两者其实本就是密不可分的！但从重要性来说，开发不一定需要测试，但测试一定需要有开发！虽市场需求我不可预测，而我想要的是在某一领域能够有一技之长，并在这个领域不断前行！</p>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django配置MySQL的设置</title>
      <link href="/2021/11/22/django-pei-zhi-mysql-de-she-zhi/"/>
      <url>/2021/11/22/django-pei-zhi-mysql-de-she-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Django配置MySQL的设置"><a href="#Django配置MySQL的设置" class="headerlink" title="Django配置MySQL的设置"></a>Django配置MySQL的设置</h1><p>在项目中的settings.py文件中，将原先的sqllite数据库注释。</p><p>然后添加</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"> <span class="token number">1</span> DATABASES <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span>     <span class="token string">'default'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token number">3</span>         <span class="token string">'ENGINE'</span><span class="token punctuation">:</span> <span class="token string">'django.db.backends.mysql'</span><span class="token punctuation">,</span> <span class="token comment">#数据库引擎</span> <span class="token number">4</span>         <span class="token string">'NAME'</span><span class="token punctuation">:</span> <span class="token string">'test'</span><span class="token punctuation">,</span>                       <span class="token comment">#数据库名</span> <span class="token number">5</span>         <span class="token string">'USER'</span><span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>                       <span class="token comment">#用户名</span> <span class="token number">6</span>         <span class="token string">'PASSWORD'</span><span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>                   <span class="token comment">#密码</span> <span class="token number">7</span>         <span class="token string">'HOST'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                           <span class="token comment">#数据库主机，默认为localhost</span> <span class="token number">8</span>         <span class="token string">'PORT'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                           <span class="token comment">#数据库端口，MySQL默认为3306</span> <span class="token number">9</span>         <span class="token string">'OPTIONS'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">10</span>             <span class="token string">'autocommit'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span><span class="token number">11</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">12</span>     <span class="token punctuation">}</span><span class="token number">13</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且将数据库名字添加到setting.py文件中的installed_apps下</p><p>在项目根目录下中的__init__.py文件中添加代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pymysqlpymysql<span class="token punctuation">.</span>install_as_MySQLdb<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章测试</title>
      <link href="/2021/11/22/ruan-jian-ce-shi/di-yi-pian-wen-zhang-ce-shi/"/>
      <url>/2021/11/22/ruan-jian-ce-shi/di-yi-pian-wen-zhang-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>以下内容为复制测试填充，非原创！</p><h1 id="一级目录"><a href="#一级目录" class="headerlink" title="一级目录"></a>一级目录</h1><p>最近看一个朋友的博客，很是一番感动。记录自己的工作、生活、心理变化，所以我受启发，觉得有必要写下自己的心事，为自己的年轻轨迹留下点什么。再就是我是一个孤单的人 ，回到家对着电脑就是我自己一个 ，我的家就像是一个孤岛，我要把自己的心思，想说的话，都留在这里，让自己能有回忆，让自己不在孤单，让和我一样孤单的人，共同分享我的生活，希望这次我能坚持，好好装扮我的空间，分享我的孤独，筑建我的心楼，加油！</p><h2 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h2>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2021/11/21/qian-duan-kai-fa/jsonwebtoken/"/>
      <url>/2021/11/21/qian-duan-kai-fa/jsonwebtoken/</url>
      
        <content type="html"><![CDATA[<h1 id="Json-Web-Token"><a href="#Json-Web-Token" class="headerlink" title="Json Web Token"></a>Json Web Token</h1><p>jwt 即 json web token。用于身份校验，当用户登录的时候，服务器会给用户分配一个token，服务不会保存。当用户需要访问服务器的时候，需要带着token，服务通过token来判断用户现在的状态，比如token失效不正确等。</p><h2 id="前后端分离时为何推荐token认证"><a href="#前后端分离时为何推荐token认证" class="headerlink" title="前后端分离时为何推荐token认证?"></a>前后端分离时为何推荐token认证?</h2><ul><li><p>Token无需存储降低服务器成本，session是将用户信息存储在服务器中的，当用户量增大时服务器的压力也会随着增大。</p></li><li><p>防御CSRF跨站伪造请求攻击，session是基于cookie进行用户识别的, cookie如果被截获，用户信息就容易泄露。</p></li><li><p>扩展性强，session需要存储无法共享，当搭建了多个服务器时其他服务器无法获取到session中的验证数据用户无法验证成功。而Token可以实现服务器间共享，这样不管哪里都可以访问到。</p></li><li><p>Token可以减轻服务器的压力，减少频繁的查询数据库。</p></li><li><p>支持跨域访问, 适用于移动平台应用</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
